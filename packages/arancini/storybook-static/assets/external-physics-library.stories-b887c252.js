var ye=Object.defineProperty;var Be=(r,i,t)=>i in r?ye(r,i,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[i]=t;var w=(r,i,t)=>(Be(r,typeof i!="symbol"?i+"":i,t),t);import{g as we,j as z,m as Pe,a as Bt,F as Me}from"./index.es-6456b573.js";import{b as xe,C as Ie,u as Se}from"./react-three-fiber.esm-dca5276d.js";import{r as ce}from"./index-76fb7be0.js";import{R as Fe}from"./timeline-composer.esm-08db1a3e.js";import"./_commonjsHelpers-de833af9.js";import"./extends-98964cd2.js";const ai=(()=>typeof P2_ARRAY_TYPE<"u"?P2_ARRAY_TYPE:typeof Float32Array<"u"?Float32Array:Array)(),ti=(r,i)=>{for(let t=0,e=i.length;t!==e;++t)r.push(i[t])},Le=function(r,i,t){t===void 0&&(t=1);const e=r.length-t;for(let n=i;n<e;n++)r[n]=r[n+t];r.length=e},Ot=(r,i)=>{const t=r.indexOf(i);t!==-1&&Le(r,t,1)};function st(r,i){return r[0]*i[1]-r[1]*i[0]}function Pi(r,i,t){return K(r,i,-Math.PI/2),_(r,r,t),r}function K(r,i,t){if(t!==0){const e=Math.cos(t),n=Math.sin(t),s=i[0],o=i[1];r[0]=e*s-n*o,r[1]=n*s+e*o}else r[0]=i[0],r[1]=i[1];return r}function pt(r,i){const t=i[0],e=i[1];return r[0]=e,r[1]=-t,r}function dt(r,i,t,e){const n=Math.cos(-e),s=Math.sin(-e),o=i[0]-t[0],a=i[1]-t[1];return r[0]=n*o-s*a,r[1]=s*o+n*a,r}function H(r,i,t,e){const n=Math.cos(e),s=Math.sin(e),o=i[0],a=i[1],c=t[0],u=t[1];r[0]=n*o-s*a+c,r[1]=s*o+n*a+u}function le(r,i,t){const e=Math.cos(-t),n=Math.sin(-t),s=i[0],o=i[1];return r[0]=e*s-n*o,r[1]=n*s+e*o,r}const Ne=K;function _e(r,i,t,e){return S(r,i,t),S(r,r,e),_(r,r,1/3),r}function d(){const r=new ai(2);return r[0]=0,r[1]=0,r}function tt(r){const i=new ai(2);return i[0]=r[0],i[1]=r[1],i}function Z(r,i){const t=new ai(2);return t[0]=r,t[1]=i,t}function G(r,i){return r[0]=i[0],r[1]=i[1],r}function R(r,i,t){return r[0]=i,r[1]=t,r}function S(r,i,t){return r[0]=i[0]+t[0],r[1]=i[1]+t[1],r}function B(r,i,t){return r[0]=i[0]-t[0],r[1]=i[1]-t[1],r}function ni(r,i,t){return r[0]=i[0]*t[0],r[1]=i[1]*t[1],r}function _(r,i,t){return r[0]=i[0]*t,r[1]=i[1]*t,r}function Fi(r,i){const t=i[0]-r[0],e=i[1]-r[1];return Math.sqrt(t*t+e*e)}function ci(r,i){const t=i[0]-r[0],e=i[1]-r[1];return t*t+e*e}function qt(r){const i=r[0],t=r[1];return Math.sqrt(i*i+t*t)}function it(r){const i=r[0],t=r[1];return i*i+t*t}function X(r,i){const t=i[0],e=i[1];let n=t*t+e*e;return n>0&&(n=1/Math.sqrt(n),r[0]=i[0]*n,r[1]=i[1]*n),r}function O(r,i){return r[0]*i[0]+r[1]*i[1]}function Ft(r,i,t,e){const n=i[0],s=i[1];return r[0]=n+e*(t[0]-n),r[1]=s+e*(t[1]-s),r}function qe(r,i,t,e){const n=i[0]-r[0],s=i[1]-r[1],o=e[0]-t[0],a=e[1]-t[1],c=(-s*(r[0]-t[0])+n*(r[1]-t[1]))/(-o*s+n*a),u=(o*(r[1]-t[1])-a*(r[0]-t[0]))/(-o*s+n*a);return c>=0&&c<=1&&u>=0&&u<=1?u:-1}class Li{constructor(i){i===void 0&&(i={}),this.lowerBound=i.lowerBound?tt(i.lowerBound):d(),this.upperBound=i.upperBound?tt(i.upperBound):d()}setFromPoints(i,t,e,n){e===void 0&&(e=0),n===void 0&&(n=0);const s=this.lowerBound,o=this.upperBound;e!==0?K(s,i[0],e):G(s,i[0]),G(o,s);const a=Math.cos(e),c=Math.sin(e);for(let u=1;u<i.length;u++){let h=i[u];if(e!==0){const l=h[0],p=h[1];ui[0]=a*l-c*p,ui[1]=c*l+a*p,h=ui}for(let l=0;l<2;l++)h[l]>o[l]&&(o[l]=h[l]),h[l]<s[l]&&(s[l]=h[l])}t&&(S(s,s,t),S(o,o,t)),n&&(s[0]-=n,s[1]-=n,o[0]+=n,o[1]+=n)}copy(i){G(this.lowerBound,i.lowerBound),G(this.upperBound,i.upperBound)}extend(i){const t=this.lowerBound,e=this.upperBound;let n=2;for(;n--;){const s=i.lowerBound[n];t[n]>s&&(t[n]=s);const o=i.upperBound[n];e[n]<o&&(e[n]=o)}}overlaps(i){const t=this.lowerBound,e=this.upperBound,n=i.lowerBound,s=i.upperBound;return(n[0]<=e[0]&&e[0]<=s[0]||t[0]<=s[0]&&s[0]<=e[0])&&(n[1]<=e[1]&&e[1]<=s[1]||t[1]<=s[1]&&s[1]<=e[1])}containsPoint(i){const t=this.lowerBound,e=this.upperBound;return t[0]<=i[0]&&i[0]<=e[0]&&t[1]<=i[1]&&i[1]<=e[1]}overlapsRay(i){const t=1/i.direction[0],e=1/i.direction[1],n=i.from,s=this.lowerBound,o=this.upperBound,a=(s[0]-n[0])*t,c=(o[0]-n[0])*t,u=(s[1]-n[1])*e,h=(o[1]-n[1])*e,l=Math.max(Math.max(Math.min(a,c),Math.min(u,h))),p=Math.min(Math.min(Math.max(a,c),Math.max(u,h)));return p<0||l>p?-1:l/i.length}}const ui=d(),Te=[0,0],Re=[0,0],Ge=[[0,0],[0,0]],Ve=[[0,0],[0,0]];function ke(r,i,t){t===void 0&&(t=0),t=t||0;const e=[0,0],n=r[1][1]-r[0][1],s=r[0][0]-r[1][0],o=n*r[0][0]+s*r[0][1],a=i[1][1]-i[0][1],c=i[0][0]-i[1][0],u=a*i[0][0]+c*i[0][1],h=n*c-a*s;return fe(h,0,t)||(e[0]=(c*o-s*u)/h,e[1]=(n*u-a*o)/h),e}function Mi(r,i,t,e){const n=i[0]-r[0],s=i[1]-r[1],o=e[0]-t[0],a=e[1]-t[1];if(o*s-a*n===0)return!1;const c=(n*(t[1]-r[1])+s*(r[0]-t[0]))/(o*s-a*n),u=(o*(r[1]-t[1])+a*(t[0]-r[0]))/(a*n-o*s);return c>=0&&c<=1&&u>=0&&u<=1}function Gt(r,i,t){return(i[0]-r[0])*(t[1]-r[1])-(t[0]-r[0])*(i[1]-r[1])}function ii(r,i,t){return Gt(r,i,t)>0}function xi(r,i,t){return Gt(r,i,t)>=0}function he(r,i,t){return Gt(r,i,t)<0}function Lt(r,i,t){return Gt(r,i,t)<=0}function De(r,i,t,e){if(e===void 0&&(e=0),e){const n=Te,s=Re;n[0]=i[0]-r[0],n[1]=i[1]-r[1],s[0]=t[0]-i[0],s[1]=t[1]-i[1];const o=n[0]*s[0]+n[1]*s[1],a=Math.sqrt(n[0]*n[0]+n[1]*n[1]),c=Math.sqrt(s[0]*s[0]+s[1]*s[1]);return Math.acos(o/(a*c))<e}else return Gt(r,i,t)===0}function Nt(r,i){const t=i[0]-r[0],e=i[1]-r[1];return t*t+e*e}function x(r,i){const t=r.length;return r[i<0?i%t+t:i%t]}function Oe(r){r.length=0}function J(r,i,t,e){for(let n=t;n<e;n++)r.push(i[n])}function Ue(r){let i=0;const t=r;for(let e=1;e<r.length;++e)(t[e][1]<t[i][1]||t[e][1]===t[i][1]&&t[e][0]>t[i][0])&&(i=e);return ii(x(r,i-1),x(r,i),x(r,i+1))?!1:(We(r),!0)}function We(r){const i=[],t=r.length;for(let e=0;e!==t;e++)i.push(r.pop());for(let e=0;e!==t;e++)r[e]=i[e]}function de(r,i){return he(x(r,i-1),x(r,i),x(r,i+1))}function Xe(r,i,t){const e=Ge,n=Ve;if(xi(x(r,i+1),x(r,i),x(r,t))&&Lt(x(r,i-1),x(r,i),x(r,t)))return!1;const s=Nt(x(r,i),x(r,t));for(let o=0;o!==r.length;++o)if(!((o+1)%r.length===i||o===i)&&xi(x(r,i),x(r,t),x(r,o+1))&&Lt(x(r,i),x(r,t),x(r,o))){e[0]=x(r,i),e[1]=x(r,t),n[0]=x(r,o),n[1]=x(r,o+1);const a=ke(e,n);if(Nt(x(r,i),a)<s)return!1}return!0}function He(r,i,t){for(let e=0;e!==r.length;++e)if(!(e===i||e===t||(e+1)%r.length===i||(e+1)%r.length===t)&&Mi(x(r,i),x(r,t),x(r,e),x(r,e+1)))return!1;return!0}function si(r,i,t,e){if(e===void 0&&(e=[]),Oe(e),i<t)for(let n=i;n<=t;n++)e.push(r[n]);else{for(let n=0;n<=t;n++)e.push(r[n]);for(let n=i;n<r.length;n++)e.push(r[n])}return e}function Ii(r){let i=[],t,e;const n=[];let s=Number.MAX_VALUE;for(let o=0;o<r.length;++o)if(de(r,o)){for(let a=0;a<r.length;++a)if(Xe(r,o,a)){t=Ii(si(r,o,a,n)),e=Ii(si(r,a,o,n));for(let c=0;c<e.length;c++)t.push(e[c]);t.length<s&&(i=t,s=t.length,i.push([x(r,o),x(r,a)]))}}return i}function Ye(r){const i=Ii(r);return i.length>0?ue(r,i):[r]}function ue(r,i){if(i.length===0)return[r];if(i instanceof Array&&i.length&&i[0]instanceof Array&&i[0].length===2&&i[0][0]instanceof Array){const t=[r];for(let e=0;e<i.length;e++){const n=i[e];for(let s=0;s<t.length;s++){const o=t[s],a=ue(o,n);if(a){t.splice(s,1),t.push(a[0],a[1]);break}}}return t}else{const t=i,e=r.indexOf(t[0]),n=r.indexOf(t[1]);return e!==-1&&n!==-1?[si(r,e,n),si(r,n,e)]:!1}}function Ke(r){const i=r;let t;for(t=0;t<i.length-1;t++)for(let e=0;e<t-1;e++)if(Mi(i[t],i[t+1],i[e],i[e+1]))return!1;for(t=1;t<i.length-2;t++)if(Mi(i[0],i[i.length-1],i[t],i[t+1]))return!1;return!0}function Di(r,i,t,e,n){n===void 0&&(n=0);const s=i[1]-r[1],o=r[0]-i[0],a=s*r[0]+o*r[1],c=e[1]-t[1],u=t[0]-e[0],h=c*t[0]+u*t[1],l=s*u-c*o;return fe(l,0,n)?[0,0]:[(u*a-o*h)/l,(s*h-c*a)/l]}function St(r,i,t,e,n,s,o){i===void 0&&(i=[]),t===void 0&&(t=[]),e===void 0&&(e=[]),n===void 0&&(n=25),s===void 0&&(s=100),o===void 0&&(o=0);let a=[0,0],c=[0,0],u=[0,0],h=0,l=0,p=0,A=0,g=0,v=0,E=0;const y=[],P=[],b=r,m=r;if(m.length<3)return i;if(o++,o>s)return console.warn("quickDecomp: max level ("+s+") reached."),i;for(let f=0;f<r.length;++f)if(de(b,f)){t.push(b[f]),h=l=Number.MAX_VALUE;for(let C=0;C<r.length;++C)ii(x(b,f-1),x(b,f),x(b,C))&&Lt(x(b,f-1),x(b,f),x(b,C-1))&&(u=Di(x(b,f-1),x(b,f),x(b,C),x(b,C-1)),he(x(b,f+1),x(b,f),u)&&(p=Nt(b[f],u),p<l&&(l=p,c=u,v=C))),ii(x(b,f+1),x(b,f),x(b,C+1))&&Lt(x(b,f+1),x(b,f),x(b,C))&&(u=Di(x(b,f+1),x(b,f),x(b,C),x(b,C+1)),ii(x(b,f-1),x(b,f),u)&&(p=Nt(b[f],u),p<h&&(h=p,a=u,g=C)));if(v===(g+1)%r.length)u[0]=(c[0]+a[0])/2,u[1]=(c[1]+a[1])/2,e.push(u),f<g?(J(y,b,f,g+1),y.push(u),P.push(u),v!==0&&J(P,b,v,b.length),J(P,b,0,f+1)):(f!==0&&J(y,b,f,b.length),J(y,b,0,g+1),y.push(u),P.push(u),J(P,b,v,f+1));else{if(v>g&&(g+=r.length),A=Number.MAX_VALUE,g<v)return i;for(let C=v;C<=g;++C)xi(x(b,f-1),x(b,f),x(b,C))&&Lt(x(b,f+1),x(b,f),x(b,C))&&(p=Nt(x(b,f),x(b,C)),p<A&&He(b,f,C)&&(A=p,E=C%r.length));f<E?(J(y,b,f,E+1),E!==0&&J(P,b,E,m.length),J(P,b,0,f+1)):(f!==0&&J(y,b,f,m.length),J(y,b,0,E+1),J(P,b,E,f+1))}return y.length<P.length?(St(y,i,t,e,n,s,o),St(P,i,t,e,n,s,o)):(St(P,i,t,e,n,s,o),St(y,i,t,e,n,s,o)),i}return i.push(r),i}function Oi(r,i){i===void 0&&(i=0);let t=0;for(let e=r.length-1;r.length>3&&e>=0;--e)De(x(r,e-1),x(r,e),x(r,e+1),i)&&(r.splice(e%r.length,1),t++);return t}function fe(r,i,t){return t===void 0&&(t=0),t=t||0,Math.abs(r-i)<=t}const at=class at{constructor(i){w(this,"direction",d());w(this,"length",1);w(this,"_currentBody",null);w(this,"_currentShape",null);i===void 0&&(i={}),this.from=i.from?tt(i.from):d(),this.to=i.to?tt(i.to):d(),this.checkCollisionResponse=i.checkCollisionResponse??!0,this.skipBackfaces=!!i.skipBackfaces,this.collisionMask=i.collisionMask??-1,this.collisionGroup=i.collisionGroup??-1,this.mode=i.mode??at.ANY,this.callback=(i==null?void 0:i.callback)||function(){},this.update()}update(){const i=this.direction;B(i,this.to,this.from),this.length=qt(i),X(i,i)}intersectBodies(i,t){for(let e=0,n=t.length;!i.shouldStop(this)&&e<n;e++){const s=t[e],o=s.getAABB();(o.overlapsRay(this)>=0||o.containsPoint(this.from))&&this.intersectBody(i,s)}}intersectBody(i,t){const e=this.checkCollisionResponse;if(e&&!t.collisionResponse)return;const n=$e;for(let s=0,o=t.shapes.length;s<o;s++){const a=t.shapes[s];if(e&&!a.collisionResponse||!(this.collisionGroup&a.collisionMask)||!(a.collisionGroup&this.collisionMask))continue;K(n,a.position,t.angle),S(n,n,t.position);const c=a.angle+t.angle;if(this.intersectShape(i,a,c,n,t),i.shouldStop(this))break}}intersectShape(i,t,e,n,s){const o=this.from;ze(o,this.direction,n)>t.boundingRadius*t.boundingRadius||(this._currentBody=s,this._currentShape=t,t.raycast(i,this,n,e),this._currentBody=this._currentShape=null)}getAABB(i){const t=this.to,e=this.from;R(i.lowerBound,Math.min(t[0],e[0]),Math.min(t[1],e[1])),R(i.upperBound,Math.max(t[0],e[0]),Math.max(t[1],e[1]))}reportIntersection(i,t,e,n){n===void 0&&(n=-1);const s=this._currentShape,o=this._currentBody;if(!(this.skipBackfaces&&O(e,this.direction)>0))switch(this.mode){case at.ALL:i.set(e,s,o,t,n),this.callback(i);break;case at.CLOSEST:(t<i.fraction||!i.hasHit())&&i.set(e,s,o,t,n);break;case at.ANY:i.set(e,s,o,t,n);break}}};w(at,"CLOSEST",1),w(at,"ANY",2),w(at,"ALL",4);let Tt=at;const Ui=d(),Ut=d();function ze(r,i,t){B(Ui,t,r);const e=O(Ui,i);return _(Ut,i,e),S(Ut,Ut,r),ci(t,Ut)}const $e=d();class Qe{constructor(){this.normal=d(),this.shape=null,this.body=null,this.faceIndex=-1,this.fraction=-1,this.isStopped=!1}reset(){R(this.normal,0,0),this.shape=null,this.body=null,this.faceIndex=-1,this.fraction=-1,this.isStopped=!1}getHitDistance(i){return Fi(i.from,i.to)*this.fraction}hasHit(){return this.fraction!==-1}getHitPoint(i,t){return Ft(i,t.from,t.to,this.fraction)}stop(){this.isStopped=!0}shouldStop(i){return this.isStopped||this.fraction!==-1&&i.mode===Tt.ANY}set(i,t,e,n,s){G(this.normal,i),this.shape=t,this.body=e,this.fraction=n,this.faceIndex=s}}class pe{constructor(){w(this,"listeners",{})}on(i,t){let e=this.listeners[i];return e===void 0&&(e=[],this.listeners[i]=e),e.indexOf(t)===-1&&e.push(t),this}off(i,t){const e=this.listeners[i];if(e){const n=e.indexOf(t);n!==-1&&e.splice(n,1)}return this}has(i,t){const e=this.listeners[i];return t?e!==void 0&&e.indexOf(t)!==-1:e!==void 0}emit(i){if(this.listeners===void 0)return this;const t=this.listeners[i.type];if(t!==void 0)for(const e of[...t])e(i);return this}}function Ze(r){const i=r.length>>1;if(i<3)return[];const t=[],e=[];for(let o=0;o<i;o++)e.push(o);let n=0,s=i;for(;s>3;){const o=e[(n+0)%s],a=e[(n+1)%s],c=e[(n+2)%s],u=r[2*o],h=r[2*o+1],l=r[2*a],p=r[2*a+1],A=r[2*c],g=r[2*c+1];let v=!1;if(je(u,h,l,p,A,g)){v=!0;for(let E=0;E<s;E++){const y=e[E];if(!(y==o||y==a||y==c)&&Je(r[2*y],r[2*y+1],u,h,l,p,A,g)){v=!1;break}}}if(v)t.push(o,a,c),e.splice((n+1)%s,1),s--,n=0;else if(n++>3*s)break}return t.push(e[0],e[1],e[2]),t}function Je(r,i,t,e,n,s,o,a){const c=o-t,u=a-e,h=n-t,l=s-e,p=r-t,A=i-e,g=c*c+u*u,v=c*h+u*l,E=c*p+u*A,y=h*h+l*l,P=h*p+l*A,b=1/(g*y-v*v),m=(y*E-v*P)*b,f=(g*P-v*E)*b;return m>=0&&f>=0&&m+f<1}function je(r,i,t,e,n,s){return(i-e)*(n-t)+(t-r)*(s-e)>=0}const j=class j{constructor(i){w(this,"body",null);w(this,"position",d());w(this,"boundingRadius",0);w(this,"area",0);this.id=j.idCounter++,this.body=null,i.position&&G(this.position,i.position),this.type=i.type,this.angle=i.angle??0,this.collisionGroup=i.collisionGroup??1,this.collisionResponse=i.collisionResponse??!0,this.collisionMask=i.collisionMask??1,this.sensor=i.sensor??!1,this.material=i.material??null}updateBoundingRadius(){}updateArea(){}raycast(i,t,e,n){}pointTest(i){return!1}worldPointToLocal(i,t){const e=this.body;return K(Wt,this.position,e.angle),S(Wt,Wt,e.position),dt(i,t,Wt,this.body.angle+this.angle),i}};w(j,"idCounter",0),w(j,"CIRCLE",1),w(j,"PARTICLE",2),w(j,"PLANE",4),w(j,"CONVEX",8),w(j,"LINE",16),w(j,"BOX",32),w(j,"CAPSULE",64),w(j,"HEIGHTFIELD",128);let I=j;const Wt=d();class mt extends I{constructor(i){i===void 0&&(i={});const t={type:I.CONVEX,vertices:[],axes:[],...i};super(t),this.axes=t.axes,this.vertices=[];for(let e=0;e<t.vertices.length;e++)this.vertices.push(tt(t.vertices[e]));this.normals=[];for(let e=0;e<t.vertices.length;e++)this.normals.push(d());if(this.updateNormals(),this.centerOfMass=d(),this.triangles=[],this.vertices.length&&(this.updateTriangles(),this.updateCenterOfMass()),this.boundingRadius=0,this.updateBoundingRadius(),this.updateArea(),this.area<0)throw new Error("Convex vertices must be given in counter-clockwise winding.")}updateNormals(){for(let i=0;i<this.vertices.length;i++){const t=this.vertices[i],e=this.vertices[(i+1)%this.vertices.length],n=this.normals[i];B(n,e,t),pt(n,n),X(n,n)}}projectOntoLocalAxis(i,t){let e=0,n=0;i=tn;for(let s=0;s<this.vertices.length;s++){const o=this.vertices[s],a=O(o,i);(e===null||a>e)&&(e=a),(n===null||a<n)&&(n=a)}if(n>e){const s=n;n=e,e=s}R(t,n,e)}projectOntoWorldAxis(i,t,e,n){let s=en;this.projectOntoLocalAxis(i,n),e!==0?K(s,i,e):s=i;const o=O(t,s);R(n,n[0]+o,n[1]+o)}updateTriangles(){this.triangles.length=0;const i=[];for(let e=0;e<this.vertices.length;e++){const n=this.vertices[e];i.push(n[0],n[1])}const t=Ze(i);for(let e=0;e<t.length;e+=3){const n=t[e],s=t[e+1],o=t[e+2];this.triangles.push([n,s,o])}}updateCenterOfMass(){const i=this.triangles,t=this.vertices,e=this.centerOfMass,n=nn;let s=on,o=rn,a=an;const c=sn;R(e,0,0);let u=0;for(let h=0;h!==i.length;h++){const l=i[h];s=t[l[0]],o=t[l[1]],a=t[l[2]],_e(n,s,o,a);const p=mt.triangleArea(s,o,a);u+=p,_(c,n,p),S(e,e,c)}_(e,e,1/u)}computeMomentOfInertia(){let i=0,t=0;const e=this.vertices.length;for(let n=e-1,s=0;s<e;n=s,s++){const o=this.vertices[n],a=this.vertices[s],c=Math.abs(st(o,a)),u=O(a,a)+O(a,o)+O(o,o);i+=c*u,t+=c}return 1/6*(i/t)}updateBoundingRadius(){const i=this.vertices;let t=0;for(let e=0;e!==i.length;e++){const n=it(i[e]);n>t&&(t=n)}this.boundingRadius=Math.sqrt(t)}updateArea(){this.updateTriangles(),this.area=0;const i=this.triangles,t=this.vertices;for(let e=0;e!==i.length;e++){const n=i[e],s=t[n[0]],o=t[n[1]],a=t[n[2]],c=mt.triangleArea(s,o,a);this.area+=c}}computeAABB(i,t,e){i.setFromPoints(this.vertices,t,e,0)}raycast(i,t,e,n){const s=cn,o=ln,a=hn,c=this.vertices;dt(s,t.from,e,n),dt(o,t.to,e,n);const u=c.length;for(let h=0;h<u&&!i.shouldStop(t);h++){const l=c[h],p=c[(h+1)%u],A=qe(s,o,l,p);A>=0&&(B(a,p,l),K(a,a,-Math.PI/2+n),X(a,a),t.reportIntersection(i,A,a,h))}}pointTest(i){const t=dn,e=un,n=this.vertices,s=n.length;let o=null;for(let a=0;a<s+1;a++){const c=n[a%s],u=n[(a+1)%s];B(t,c,i),B(e,u,i);const h=st(t,e);if(o===null&&(o=h),h*o<0)return!1;o=h}return!0}static triangleArea(i,t,e){return((t[0]-i[0])*(e[1]-i[1])-(e[0]-i[0])*(t[1]-i[1]))*.5}}const tn=d(),en=d(),nn=d(),sn=d(),on=d(),rn=d(),an=d(),cn=d(),ln=d(),hn=d(),dn=d(),un=d(),W=class W extends pe{constructor(t){t===void 0&&(t={});super();w(this,"world",null);this.id=t.id||++W._idCounter,this.index=-1,this.shapes=[],this.mass=t.mass||0,this.invMass=0,this.inertia=0,this.invInertia=0,this.invMassSolve=0,this.invInertiaSolve=0,this.fixedRotation=!!t.fixedRotation,this.fixedX=!!t.fixedX,this.fixedY=!!t.fixedY,this.massMultiplier=d(),this.position=t.position?tt(t.position):d(),this.interpolatedPosition=tt(this.position),this.previousPosition=tt(this.position),this.velocity=t.velocity?tt(t.velocity):d(),this.vlambda=d(),this.wlambda=0,this.angle=t.angle||0,this.previousAngle=this.angle,this.interpolatedAngle=this.angle,this.angularVelocity=t.angularVelocity||0,this.force=t.force?tt(t.force):d(),this.angularForce=t.angularForce||0,this.damping=t.damping??.1,this.angularDamping=t.angularDamping??.1,this.type=W.STATIC,t.type!==void 0?this.type=t.type:t.mass?this.type=W.DYNAMIC:this.type=W.STATIC,this.boundingRadius=0,this.aabb=new Li,this.aabbNeedsUpdate=!0,this.allowSleep=t.allowSleep??!0,this.wantsToSleep=!1,this.sleepState=W.AWAKE,this.sleepSpeedLimit=t.sleepSpeedLimit??.2,this.sleepTimeLimit=t.sleepTimeLimit??1,this.idleTime=0,this.timeLastSleepy=0,this.collisionResponse=t.collisionResponse??!0,this.ccdSpeedThreshold=t.ccdSpeedThreshold??-1,this.ccdIterations=t.ccdIterations??10,this.gravityScale=t.gravityScale??1,this.islandId=-1,this.concavePath=null,this._wakeUpAfterNarrowphase=!1,this.updateMassProperties()}updateSolveMassProperties(){this.sleepState===W.SLEEPING||this.type===W.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve=0):(this.invMassSolve=this.invMass,this.invInertiaSolve=this.invInertia)}setDensity(t){const e=this.getArea();this.mass=e*t,this.updateMassProperties()}getArea(){let t=0;for(let e=0;e<this.shapes.length;e++)t+=this.shapes[e].area;return t}getAABB(){return this.aabbNeedsUpdate&&this.updateAABB(),this.aabb}updateAABB(){const t=this.shapes,e=t.length,n=fn,s=this.angle;for(let o=0;o!==e;o++){const a=t[o],c=a.angle+s;H(n,a.position,this.position,s),a.computeAABB(fi,n,c),o===0?this.aabb.copy(fi):this.aabb.extend(fi)}this.aabbNeedsUpdate=!1}updateBoundingRadius(){const t=this.shapes,e=t.length;let n=0;for(let s=0;s!==e;s++){const o=t[s],a=qt(o.position),c=o.boundingRadius;a+c>n&&(n=a+c)}this.boundingRadius=n}addShape(t,e,n){if(t.body)throw new Error("A shape can only be added to one body.");const s=this.world;if(s&&s.stepping)throw new Error("A shape cannot be added during step.");t.body=this,e?G(t.position,e):R(t.position,0,0),t.angle=n||0,this.shapes.push(t),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0}removeShape(t){const e=this.world;if(e&&e.stepping)throw new Error("A shape cannot be removed during step.");const n=this.shapes.indexOf(t);return n!==-1?(this.shapes.splice(n,1),this.aabbNeedsUpdate=!0,t.body=null,!0):!1}updateMassProperties(){if(this.type===W.STATIC||this.type===W.KINEMATIC)this.mass=Number.MAX_VALUE,this.invMass=0,this.inertia=Number.MAX_VALUE,this.invInertia=0;else{const t=this.shapes,e=t.length;let n=0;if(this.fixedRotation)this.inertia=Number.MAX_VALUE,this.invInertia=0;else{for(let s=0;s<e;s++){const o=t[s],a=it(o.position),c=o.computeMomentOfInertia();n+=c+a}this.inertia=this.mass*n,this.invInertia=n>0?1/n:0}this.invMass=1/this.mass,R(this.massMultiplier,this.fixedX?0:1,this.fixedY?0:1)}}applyForce(t,e){if(S(this.force,this.force,t),e){const n=st(e,t);this.angularForce+=n}}applyForceLocal(t,e){e=e||gn;const n=pn,s=mn;this.vectorToWorldFrame(n,t),this.vectorToWorldFrame(s,e),this.applyForce(n,s)}applyImpulse(t,e){if(this.type!==W.DYNAMIC)return;const n=vn;if(_(n,t,this.invMass),ni(n,this.massMultiplier,n),S(this.velocity,n,this.velocity),e){let s=st(e,t);s*=this.invInertia,this.angularVelocity+=s}}applyImpulseLocal(t,e){e=e||En;const n=An,s=bn;this.vectorToWorldFrame(n,t),this.vectorToWorldFrame(s,e),this.applyImpulse(n,s)}toLocalFrame(t,e){dt(t,e,this.position,this.angle)}toWorldFrame(t,e){H(t,e,this.position,this.angle)}vectorToLocalFrame(t,e){le(t,e,this.angle)}vectorToWorldFrame(t,e){Ne(t,e,this.angle)}fromPolygon(t,e){e===void 0&&(e={});for(let c=this.shapes.length;c>=0;--c)this.removeShape(this.shapes[c]);const n=[];for(let c=0;c<t.length;c++)n[c]=tt(t[c]);if(Ue(n),e.removeCollinearPoints!==void 0&&(typeof e.removeCollinearPoints=="boolean"?e.removeCollinearPoints===!0&&Oi(n):Oi(n,e.removeCollinearPoints)),!e.skipSimpleCheck&&!Ke(n))return!1;const s=this.concavePath=[];for(let c=0;c<n.length;c++)s[c]=tt(n[c]);let o;if(e.optimalDecomp){if(o=Ye(n),o===!1)throw new Error("Convex decomposition failed!")}else o=St(n);const a=d();for(let c=0;c!==o.length;c++){let u=new mt({vertices:o[c]});for(let h=0;h!==u.vertices.length;h++){const l=u.vertices[h];B(l,l,u.centerOfMass)}G(a,u.centerOfMass),u=new mt({vertices:u.vertices}),this.addShape(u,a)}return this.adjustCenterOfMass(),this.aabbNeedsUpdate=!0,!0}adjustCenterOfMass(){const t=Cn,e=yn,n=Bn;let s=0;R(e,0,0);for(let o=0;o!==this.shapes.length;o++){const a=this.shapes[o];_(t,a.position,a.area),S(e,e,t),s+=a.area}_(n,e,1/s);for(let o=0;o!==this.shapes.length;o++){const a=this.shapes[o];B(a.position,a.position,n)}S(this.position,this.position,n);for(let o=0;this.concavePath&&o<this.concavePath.length;o++)B(this.concavePath[o],this.concavePath[o],n);this.updateMassProperties(),this.updateBoundingRadius()}setZeroForce(){const t=this.force;t[0]=t[1]=this.angularForce=0}applyDamping(t){if(this.type===W.DYNAMIC){const e=this.velocity;_(e,e,Math.pow(1-this.damping,t)),this.angularVelocity*=Math.pow(1-this.angularDamping,t)}}wakeUp(){const t=this.sleepState;this.sleepState=W.AWAKE,this.idleTime=0,t!==W.AWAKE&&this.emit({type:"wakeup"})}sleep(){this.sleepState=W.SLEEPING,this.angularVelocity=this.angularForce=0,R(this.velocity,0,0),R(this.force,0,0),this.emit({type:"sleep"})}sleepTick(t,e,n){if(!this.allowSleep||this.type===W.SLEEPING)return;this.wantsToSleep=!1;const s=it(this.velocity)+Math.pow(this.angularVelocity,2),o=Math.pow(this.sleepSpeedLimit,2);s>=o?(this.idleTime=0,this.sleepState=W.AWAKE):(this.idleTime+=n,this.sleepState!==W.SLEEPY&&(this.sleepState=W.SLEEPY,this.emit({type:"sleepy"}))),this.idleTime>this.sleepTimeLimit&&(e?this.wantsToSleep=!0:this.sleep())}overlaps(t){return this.world===null?!1:this.world.overlapKeeper.bodiesAreOverlapping(this,t)}integrate(t){const e=this.invMass,n=this.force,s=this.position,o=this.velocity;G(this.previousPosition,this.position),this.previousAngle=this.angle,this.fixedRotation||(this.angularVelocity+=this.angularForce*this.invInertia*t),_(Xt,n,t*e),ni(Xt,this.massMultiplier,Xt),S(o,Xt,o),this.integrateToTimeOfImpact(t)||(_(At,o,t),S(s,s,At),this.fixedRotation||(this.angle+=this.angularVelocity*t)),this.aabbNeedsUpdate=!0}getVelocityAtPoint(t,e){return Pi(t,e,this.angularVelocity),B(t,this.velocity,t),t}integrateToTimeOfImpact(t){if(this.world===null)throw new Error("world is not set for body");if(this.ccdSpeedThreshold<0||it(this.velocity)<Math.pow(this.ccdSpeedThreshold,2))return!1;const e=[],n=this.world.disabledBodyCollisionPairs;for(let g=0;g<n.length;g+=2){const v=n[g],E=n[g+1];v===this?e.push(E):E===this&&e.push(v)}X(wn,this.velocity),_(ct,this.velocity,t),S(ct,ct,this.position),B(wt,ct,this.position);const s=this.angularVelocity*t,o=qt(wt);let a=1,c=null;G(ut.from,this.position),G(ut.to,ct),ut.update();for(let g=0;g<this.shapes.length;g++){const v=this.shapes[g];if(Ht.reset(),ut.collisionGroup=v.collisionGroup,ut.collisionMask=v.collisionMask,this.world.raycast(Ht,ut),c=Ht.body,c!==null&&(c===this||e.indexOf(c)!==-1)&&(c=null),c)break}if(!c||!a)return!1;Ht.getHitPoint(ct,ut),B(wt,ct,this.position),a=Fi(ct,this.position)/o;const u=this.angle;G(pi,this.position);let h=0,l=0,p=a,A=1;for(;A>=l&&h<this.ccdIterations;)h++,p=(A+l)/2,_(At,wt,p),S(this.position,pi,At),this.angle=u+s*p,this.updateAABB(),this.aabb.overlaps(c.aabb)&&this.world.narrowphase.bodiesOverlap(this,c,!0)?A=p:l=p;return a=A,G(this.position,pi),this.angle=u,_(At,wt,a),S(this.position,this.position,At),this.fixedRotation||(this.angle+=s*a),!0}resetConstraintVelocity(){const t=this.vlambda;R(t,0,0),this.wlambda=0}addConstraintVelocity(){const t=this.velocity;S(t,t,this.vlambda),this.angularVelocity+=this.wlambda}};w(W,"DYNAMIC",1),w(W,"STATIC",2),w(W,"KINEMATIC",4),w(W,"AWAKE",0),w(W,"SLEEPY",1),w(W,"SLEEPING",2),w(W,"_idCounter",0);let D=W;const fi=new Li,fn=d(),pn=d(),mn=d(),gn=d(),vn=d(),An=d(),bn=d(),En=d(),Cn=d(),yn=d(),Bn=d(),Xt=d(),At=d(),Ht=new Qe,ut=new Tt({mode:Tt.CLOSEST,skipBackfaces:!0}),wn=d(),ct=d(),wt=d(),pi=d(),et=class et{static boundingRadiusCheck(i,t){const e=ci(i.position,t.position),n=i.boundingRadius+t.boundingRadius;return e<=n*n}static aabbCheck(i,t){return i.getAABB().overlaps(t.getAABB())}static canCollide(i,t){const e=D.KINEMATIC,n=D.STATIC,s=i.type,o=t.type;return!(s===n&&o===n||s===e&&o===n||s===n&&o===e||s===e&&o===e||i.sleepState===D.SLEEPING&&t.sleepState===D.SLEEPING||i.sleepState===D.SLEEPING&&o===n||t.sleepState===D.SLEEPING&&s===n)}constructor(i){this.type=i,this.result=[],this.world=void 0,this.boundingVolumeType=et.AABB}setWorld(i){this.world=i}boundingVolumeCheck(i,t){switch(this.boundingVolumeType){case et.BOUNDING_CIRCLE:return et.boundingRadiusCheck(i,t);case et.AABB:return et.aabbCheck(i,t);default:throw new Error("Bounding volume type not recognized: "+this.boundingVolumeType)}}};w(et,"AABB",1),w(et,"BOUNDING_CIRCLE",2),w(et,"NAIVE",1),w(et,"SAP",2);let _t=et,Ni=class extends mt{constructor(i){i===void 0&&(i={});const t=i.width??1,e=i.height??1,n=[Z(-t/2,-e/2),Z(t/2,-e/2),Z(t/2,e/2),Z(-t/2,e/2)],s={...i,type:I.BOX,vertices:n};super(s),this.width=t,this.height=e,this.updateBoundingRadius(),this.updateArea()}computeMomentOfInertia(){const i=this.width,t=this.height;return(t*t+i*i)/12}updateBoundingRadius(){const i=this.width,t=this.height;this.boundingRadius=Math.sqrt(i*i+t*t)/2}computeAABB(i,t,e){const n=Math.abs(Math.cos(e)),s=Math.abs(Math.sin(e)),o=this.width,a=this.height,c=(o*s+a*n)*.5,u=(a*s+o*n)*.5,h=i.lowerBound,l=i.upperBound,p=t[0],A=t[1];h[0]=p-u,h[1]=A-c,l[0]=p+u,l[1]=A+c}updateArea(){this.area=this.width*this.height}pointTest(i){return Math.abs(i[0])<=this.width*.5&&Math.abs(i[1])<=this.height*.5}};class _i extends I{constructor(i){i===void 0&&(i={});const t={radius:1,...i,type:I.CIRCLE};super(t),this.radius=t.radius,this.updateBoundingRadius(),this.updateArea()}updateBoundingRadius(){this.boundingRadius=this.radius}computeMomentOfInertia(){const i=this.radius;return i*i/2}updateArea(){this.area=Math.PI*this.radius*this.radius}computeAABB(i,t){const e=this.radius;R(i.upperBound,e,e),R(i.lowerBound,-e,-e),t&&(S(i.lowerBound,i.lowerBound,t),S(i.upperBound,i.upperBound,t))}raycast(i,t,e){const n=t.from,s=t.to,o=this.radius,a=Math.pow(s[0]-n[0],2)+Math.pow(s[1]-n[1],2),c=2*((s[0]-n[0])*(n[0]-e[0])+(s[1]-n[1])*(n[1]-e[1])),u=Math.pow(n[0]-e[0],2)+Math.pow(n[1]-e[1],2)-Math.pow(o,2),h=Math.pow(c,2)-4*a*u,l=Pn,p=Mn;if(!(h<0))if(h===0)Ft(l,n,s,h),B(p,l,e),X(p,p),t.reportIntersection(i,h,p,-1);else{const A=Math.sqrt(h),g=1/(2*a),v=(-c-A)*g,E=(-c+A)*g;if(v>=0&&v<=1&&(Ft(l,n,s,v),B(p,l,e),X(p,p),t.reportIntersection(i,v,p,-1),i.shouldStop(t)))return;E>=0&&E<=1&&(Ft(l,n,s,E),B(p,l,e),X(p,p),t.reportIntersection(i,E,p,-1))}}pointTest(i){const t=this.radius;return it(i)<=t*t}}const Pn=d(),Mn=d(),Et=class Et{constructor(i,t,e,n){this.bodyA=i,this.bodyB=t,this.minForce=e??-Number.MAX_VALUE,this.maxForce=n??Number.MAX_VALUE,this.maxBias=Number.MAX_VALUE,this.stiffness=Et.DEFAULT_STIFFNESS,this.relaxation=Et.DEFAULT_RELAXATION,this.G=new ai(6);for(let s=0;s<6;s++)this.G[s]=0;this.offset=0,this.a=0,this.b=0,this.epsilon=0,this.timeStep=1/60,this.needsUpdate=!0,this.multiplier=0,this.relativeVelocity=0,this.enabled=!0,this.lambda=this.B=this.invC=this.minForceDt=this.maxForceDt=0,this.index=-1}update(){const i=this.stiffness,t=this.relaxation,e=this.timeStep;this.a=4/(e*(1+4*t)),this.b=4*t/(1+4*t),this.epsilon=4/(e*e*i*(1+4*t)),this.needsUpdate=!1}gmult(i,t,e,n,s){return i[0]*t[0]+i[1]*t[1]+i[2]*e+i[3]*n[0]+i[4]*n[1]+i[5]*s}computeB(i,t,e){const n=this.computeGW();let s=this.computeGq();const o=this.maxBias;Math.abs(s)>o&&(s=s>0?o:-o);const a=this.computeGiMf();return-s*i-n*t-a*e}computeGq(){const i=this.G,t=this.bodyA,e=this.bodyB,n=t.angle,s=e.angle;return this.gmult(i,xn,n,In,s)+this.offset}computeGW(){const i=this.G,t=this.bodyA,e=this.bodyB,n=t.velocity,s=e.velocity,o=t.angularVelocity,a=e.angularVelocity;return this.gmult(i,n,o,s,a)+this.relativeVelocity}computeGWlambda(){const i=this.G,t=this.bodyA,e=this.bodyB,n=t.vlambda,s=e.vlambda,o=t.wlambda,a=e.wlambda;return this.gmult(i,n,o,s,a)}computeGiMf(){const i=this.bodyA,t=this.bodyB,e=i.force,n=i.angularForce,s=t.force,o=t.angularForce,a=i.invMassSolve,c=t.invMassSolve,u=i.invInertiaSolve,h=t.invInertiaSolve,l=this.G;return _(Yt,e,a),ni(Yt,i.massMultiplier,Yt),_(Kt,s,c),ni(Kt,t.massMultiplier,Kt),this.gmult(l,Yt,n*u,Kt,o*h)}computeGiMGt(){const i=this.bodyA,t=this.bodyB,e=i.invMassSolve,n=t.invMassSolve,s=i.invInertiaSolve,o=t.invInertiaSolve,a=this.G;return a[0]*a[0]*e*i.massMultiplier[0]+a[1]*a[1]*e*i.massMultiplier[1]+a[2]*a[2]*s+a[3]*a[3]*n*t.massMultiplier[0]+a[4]*a[4]*n*t.massMultiplier[1]+a[5]*a[5]*o}addToWlambda(i){const t=this.bodyA,e=this.bodyB,n=t.invMassSolve,s=e.invMassSolve,o=t.invInertiaSolve,a=e.invInertiaSolve,c=this.G;Wi(t.vlambda,c[0],c[1],n,i,t.massMultiplier),t.wlambda+=o*c[2]*i,Wi(e.vlambda,c[3],c[4],s,i,e.massMultiplier),e.wlambda+=a*c[5]*i}computeInvC(i){return 1/(this.computeGiMGt()+i)}};w(Et,"DEFAULT_STIFFNESS",1e6),w(Et,"DEFAULT_RELAXATION",4);let ht=Et;const xn=d(),In=d(),Yt=d(),Kt=d();function Wi(r,i,t,e,n,s){r[0]+=i*e*n*s[0],r[1]+=t*e*n*s[1]}function Sn(r,i,t,e,n){r[0]=i[0]+t[0]-e[0]-n[0],r[1]=i[1]+t[1]-e[1]-n[1]}const Xi=d(),Hi=d(),Yi=d(),Ki=new _i({radius:1});class Fn extends ht{constructor(i,t){super(i,t,0,Number.MAX_VALUE),this.contactPointA=d(),this.penetrationVec=d(),this.contactPointB=d(),this.normalA=d(),this.restitution=0,this.firstImpact=!1,this.shapeA=Ki,this.shapeB=Ki}computeB(i,t,e){const n=this.bodyA,s=this.bodyB,o=this.contactPointA,a=this.contactPointB,c=n.position,u=s.position,h=this.normalA,l=this.G,p=st(o,h),A=st(a,h);l[0]=-h[0],l[1]=-h[1],l[2]=-p,l[3]=h[0],l[4]=h[1],l[5]=A;let g,v;if(this.firstImpact&&this.restitution!==0)v=0,g=1/t*(1+this.restitution)*this.computeGW();else{const P=this.penetrationVec;Sn(P,u,a,c,o),v=O(h,P)+this.offset,g=this.computeGW()}const E=this.computeGiMf();return-v*i-g*t-e*E}getVelocityAlongNormal(){return this.bodyA.getVelocityAtPoint(Xi,this.contactPointA),this.bodyB.getVelocityAtPoint(Hi,this.contactPointB),B(Yi,Xi,Hi),O(this.normalA,Yi)}}class qi{constructor(i){w(this,"objects",[]);(i==null?void 0:i.size)!==void 0&&this.resize(i.size)}resize(i){const t=this.objects;for(;t.length>i;)t.pop();for(;t.length<i;)t.push(this.create());return this}get(){const i=this.objects;return i.length?i.pop():this.create()}release(i){return this.destroy(i),this.objects.push(i),this}}class Ln extends qi{create(){return new Fn(mi,mi)}destroy(i){return i.bodyA=i.bodyB=mi,this}}const mi=new D;class me extends ht{constructor(i,t,e){e===void 0&&(e=Number.MAX_VALUE),super(i,t,-e,e),this.contactPointA=d(),this.contactPointB=d(),this.t=d(),this.contactEquations=[],this.shapeA=null,this.shapeB=null,this.frictionCoefficient=.3}setSlipForce(i){this.maxForce=i,this.minForce=-i}getSlipForce(){return this.maxForce}computeB(i,t,e){const n=this.contactPointA,s=this.contactPointB,o=this.t,a=this.G;a[0]=-o[0],a[1]=-o[1],a[2]=-st(n,o),a[3]=o[0],a[4]=o[1],a[5]=st(s,o);const c=this.computeGW(),u=this.computeGiMf();return-c*t-e*u}}class Nn extends qi{create(){return new me(gi,gi)}destroy(i){return i.bodyA=i.bodyB=gi,this}}const gi=new D;class ei{constructor(){w(this,"data",{});w(this,"keys",[])}getKey(i,t){return i=i|0,t=t|0,(i|0)===(t|0)?-1:((i|0)>(t|0)?i<<16|t&65535:t<<16|i&65535)|0}getByKey(i){return i=i|0,this.data[i]}get(i,t){return this.data[this.getKey(i,t)]}set(i,t,e){if(!e)throw new Error("No data!");const n=this.getKey(i,t);return this.data[n]||this.keys.push(n),this.data[n]=e,n}reset(){this.keys=[],this.data={}}copy(i){this.keys=i.keys,this.data=i.data}}class _n{constructor(){w(this,"convexLine",(()=>function(i,t,e,n,s,o,a,c,u){return 0})());w(this,"lineBox",(()=>function(i,t,e,n,s,o,a,c,u){return 0})());w(this,"convexCapsule",(()=>{var i=this;return function(t,e,n,s,o,a,c,u,h){h===void 0&&(h=!1);const l=rs,p=a.length/2;R(l,p,0),H(l,l,c,u);const A=i.circleConvex(o,a,l,u,t,e,n,s,h,a.radius);R(l,-p,0),H(l,l,c,u);const g=i.circleConvex(o,a,l,u,t,e,n,s,h,a.radius);if(h&&A+g!==0)return 1;const v=os;return Ei(v,a),i.convexConvex(t,e,n,s,o,v,c,u,h)+A+g}})());w(this,"lineCapsule",(()=>function(i,t,e,n,s,o,a,c,u){return 0})());w(this,"capsuleCapsule",(()=>{var i=this;return function(t,e,n,s,o,a,c,u,h){h===void 0&&(h=!1);let l=!0;const p=as,A=cs;let g=0;for(let P=0;P<2;P++){R(p,(P===0?-1:1)*e.length/2,0),H(p,p,n,s);for(let b=0;b<2;b++){R(A,(b===0?-1:1)*a.length/2,0),H(A,A,c,u),i.enableFrictionReduction&&(l=i.enableFriction,i.enableFriction=!1);const m=i.circleCircle(t,e,p,s,o,a,A,u,h,e.radius,a.radius);if(i.enableFrictionReduction&&(i.enableFriction=l),h&&m!==0)return 1;g+=m}}i.enableFrictionReduction&&(l=i.enableFriction,i.enableFriction=!1);const v=ls;Ei(v,e);const E=i.convexCapsule(t,v,n,s,o,a,c,u,h);if(i.enableFrictionReduction&&(i.enableFriction=l),h&&E!==0)return 1;g+=E,i.enableFrictionReduction&&(l=i.enableFriction,i.enableFriction=!1),Ei(v,a);const y=i.convexCapsule(o,v,c,u,t,e,n,s,h);return i.enableFrictionReduction&&(i.enableFriction=l),h&&y!==0?1:(g+=y,i.enableFrictionReduction&&g&&i.enableFriction&&i.frictionEquations.push(i.createFrictionFromAverage(g)),g)}})());w(this,"lineLine",(()=>function(i,t,e,n,s,o,a,c,u){return 0})());w(this,"planeLine",(()=>{var i=this;return function(t,e,n,s,o,a,c,u,h){h===void 0&&(h=!1);const l=rt,p=ft,A=bt,g=Pt,v=Mt,E=xt,y=$t,P=vi,b=zi,m=Ji;let f=0;R(l,-a.length/2,0),R(p,a.length/2,0),H(A,l,c,u),H(g,p,c,u),G(l,A),G(p,g),B(v,p,l),X(E,v),pt(b,E),K(P,zt,s),m[0]=l,m[1]=p;for(let C=0;C<m.length;C++){const M=m[C];B(y,M,n);const F=O(y,P);if(F<0){if(h)return 1;const L=i.createContactEquation(t,o,e,a);f++,G(L.normalA,P),X(L.normalA,L.normalA),_(y,P,F),B(L.contactPointA,M,y),B(L.contactPointA,L.contactPointA,t.position),B(L.contactPointB,M,c),S(L.contactPointB,L.contactPointB,c),B(L.contactPointB,L.contactPointB,o.position),i.contactEquations.push(L),i.enableFrictionReduction||i.enableFriction&&i.frictionEquations.push(i.createFrictionFromContact(L))}}return h?0:(i.enableFrictionReduction||f&&i.enableFriction&&i.frictionEquations.push(i.createFrictionFromAverage(f)),f)}})());w(this,"particleCapsule",(()=>{var i=this;return function(t,e,n,s,o,a,c,u,h){return h===void 0&&(h=!1),i.circleLine(t,e,n,s,o,a,c,u,h,a.radius,0)}})());w(this,"circleLine",(()=>{var i=this;return function(t,e,n,s,o,a,c,u,h,l,p){h===void 0&&(h=!1),l===void 0&&(l=0),p===void 0&&(p=e.radius);const A=rt,g=ft,v=bt,E=Pt,y=Mt,P=xt,b=$t,m=vi,f=zi,C=$i,M=Qi,F=qn,L=Ai,V=bi,q=Ji,U=a.length/2;R(m,-U,0),R(f,U,0),H(C,m,c,u),H(M,f,c,u),G(m,C),G(f,M),B(P,f,m),X(b,P),pt(y,b),B(F,n,m);const Y=O(F,y);B(E,m,c),B(L,n,c);const Q=p+l;if(Math.abs(Y)<Q){_(A,y,Y),B(v,n,A),_(g,y,O(y,L)),X(g,g),_(g,g,l),S(v,v,g);const $=O(b,v),nt=O(b,m),N=O(b,f);if($>nt&&$<N){if(h)return 1;const k=i.createContactEquation(t,o,e,a);return _(k.normalA,A,-1),X(k.normalA,k.normalA),_(k.contactPointA,k.normalA,p),S(k.contactPointA,k.contactPointA,n),B(k.contactPointA,k.contactPointA,t.position),B(k.contactPointB,v,c),S(k.contactPointB,k.contactPointB,c),B(k.contactPointB,k.contactPointB,o.position),i.contactEquations.push(k),i.enableFriction&&i.frictionEquations.push(i.createFrictionFromContact(k)),1}}q[0]=m,q[1]=f;for(let $=0;$<q.length;$++){const nt=q[$];if(B(F,nt,n),it(F)<Math.pow(Q,2)){if(h)return 1;const N=i.createContactEquation(t,o,e,a);return G(N.normalA,F),X(N.normalA,N.normalA),_(N.contactPointA,N.normalA,p),S(N.contactPointA,N.contactPointA,n),B(N.contactPointA,N.contactPointA,t.position),B(N.contactPointB,nt,c),_(V,N.normalA,-l),S(N.contactPointB,N.contactPointB,V),S(N.contactPointB,N.contactPointB,c),B(N.contactPointB,N.contactPointB,o.position),i.contactEquations.push(N),i.enableFriction&&i.frictionEquations.push(i.createFrictionFromContact(N)),1}}return 0}})());w(this,"circleCapsule",(()=>{var i=this;return function(t,e,n,s,o,a,c,u,h){return h===void 0&&(h=!1),i.circleLine(t,e,n,s,o,a,c,u,h,a.radius)}})());w(this,"circleConvex",(()=>{var i=this;return function(t,e,n,s,o,a,c,u,h,l){h===void 0&&(h=!1),l===void 0&&(l=e.radius);const p=rt,A=ft,g=bt,v=Pt,E=Mt,y=xt,P=$t,b=vi,m=$i,f=Qi,C=Ai,M=bi,F=Zi;let L=-1,V=Number.MAX_VALUE;R(y,0,0),dt(P,n,c,u);const q=a.vertices,U=a.normals,Y=q.length;let Q=-1,$=-Number.MAX_VALUE;const nt=a.boundingRadius+l;for(let N=0;N<Y;N++){B(b,P,q[N]);const k=O(U[N],b);if(k>nt)return 0;k>$&&($=k,Q=N)}for(let N=Q+Y-1;N<Q+Y+2;N++){const k=q[N%Y],T=U[N%Y];if(_(M,T,-l),S(M,M,P),us(M,a)){B(F,k,M);const hi=Math.abs(O(F,T));hi<V&&(V=hi,L=N)}}if(L!==-1){if(h)return 1;const N=q[L%Y],k=q[(L+1)%Y];H(p,N,c,u),H(A,k,c,u),B(g,A,p),X(v,g),pt(E,v),_(M,E,-l),S(M,M,n),_(C,E,V),S(C,C,M);const T=i.createContactEquation(t,o,e,a);return B(T.normalA,M,n),X(T.normalA,T.normalA),_(T.contactPointA,T.normalA,l),S(T.contactPointA,T.contactPointA,n),B(T.contactPointA,T.contactPointA,t.position),B(T.contactPointB,C,c),S(T.contactPointB,T.contactPointB,c),B(T.contactPointB,T.contactPointB,o.position),i.contactEquations.push(T),i.enableFriction&&i.frictionEquations.push(i.createFrictionFromContact(T)),1}if(l>0&&Q!==-1)for(let N=Q+Y;N<Q+Y+2;N++){const k=q[N%Y];if(B(m,k,P),it(m)<l*l){if(h)return 1;H(f,k,c,u),B(m,f,n);const T=i.createContactEquation(t,o,e,a);return G(T.normalA,m),X(T.normalA,T.normalA),_(T.contactPointA,T.normalA,l),S(T.contactPointA,T.contactPointA,n),B(T.contactPointA,T.contactPointA,t.position),B(T.contactPointB,f,c),S(T.contactPointB,T.contactPointB,c),B(T.contactPointB,T.contactPointB,o.position),i.contactEquations.push(T),i.enableFriction&&i.frictionEquations.push(i.createFrictionFromContact(T)),1}}return 0}})());w(this,"particleConvex",(()=>{var i=this;return function(t,e,n,s,o,a,c,u,h){h===void 0&&(h=!1);const l=rt,p=ft,A=bt,g=Pt,v=Mt,E=xt,y=$t,P=Ai,b=bi,m=Zi,f=a.vertices;let C=Number.MAX_VALUE,M=!1;if(!ds(n,a,c,u))return 0;if(h)return 1;for(let F=0,L=f.length;F!==L+1;F++){const V=f[F%L],q=f[(F+1)%L];K(l,V,u),K(p,q,u),S(l,l,c),S(p,p,c),B(A,p,l),X(g,A),pt(v,g),B(E,l,c),B(y,n,c),B(b,l,n);const U=Math.abs(O(b,v));U<C&&(C=U,_(P,v,U),S(P,P,n),G(m,v),M=!0)}if(M){const F=i.createContactEquation(t,o,e,a);return _(F.normalA,m,-1),X(F.normalA,F.normalA),R(F.contactPointA,0,0),S(F.contactPointA,F.contactPointA,n),B(F.contactPointA,F.contactPointA,t.position),B(F.contactPointB,P,c),S(F.contactPointB,F.contactPointB,c),B(F.contactPointB,F.contactPointB,o.position),i.contactEquations.push(F),i.enableFriction&&i.frictionEquations.push(i.createFrictionFromContact(F)),1}return 0}})());w(this,"circleCircle",(()=>{var i=this;return function(t,e,n,s,o,a,c,u,h,l,p){h===void 0&&(h=!1),l===void 0&&(l=e.radius),p===void 0&&(p=a.radius);const A=rt;B(A,n,c);const g=l+p;if(it(A)>g*g)return 0;if(h)return 1;const v=i.createContactEquation(t,o,e,a),E=v.contactPointA,y=v.contactPointB,P=v.normalA;return B(P,c,n),X(P,P),_(E,P,l),_(y,P,-p),ji(E,E,n,t.position),ji(y,y,c,o.position),i.contactEquations.push(v),i.enableFriction&&i.frictionEquations.push(i.createFrictionFromContact(v)),1}})());w(this,"planeConvex",(()=>{var i=this;return function(t,e,n,s,o,a,c,u,h){h===void 0&&(h=!1);const l=rt,p=ft,A=bt,g=Pt,v=Mt,E=xt;let y=0;K(p,zt,s),le(v,p,u),dt(g,n,c,u);const P=a.vertices;for(let b=0,m=P.length;b!==m;b++){const f=P[b];if(B(E,f,g),O(E,v)<=0){if(h)return 1;H(l,f,c,u),B(A,l,n),y++;const C=i.createContactEquation(t,o,e,a);B(A,l,n),G(C.normalA,p);const M=O(A,C.normalA);_(A,C.normalA,M),B(C.contactPointB,l,o.position),B(C.contactPointA,l,A),B(C.contactPointA,C.contactPointA,t.position),i.contactEquations.push(C),i.enableFrictionReduction||i.enableFriction&&i.frictionEquations.push(i.createFrictionFromContact(C))}}return i.enableFrictionReduction&&i.enableFriction&&y&&i.frictionEquations.push(i.createFrictionFromAverage(y)),y}})());w(this,"particlePlane",(()=>{var i=this;return function(t,e,n,s,o,a,c,u,h){h===void 0&&(h=!1);const l=rt,p=ft;u=u||0,B(l,n,c),K(p,zt,u);const A=O(l,p);if(A>0)return 0;if(h)return 1;const g=i.createContactEquation(o,t,a,e);return G(g.normalA,p),_(l,g.normalA,A),B(g.contactPointA,n,l),B(g.contactPointA,g.contactPointA,o.position),B(g.contactPointB,n,t.position),i.contactEquations.push(g),i.enableFriction&&i.frictionEquations.push(i.createFrictionFromContact(g)),1}})());w(this,"circleParticle",(()=>{var i=this;return function(t,e,n,s,o,a,c,u,h){h===void 0&&(h=!1);const l=rt,p=e.radius;if(B(l,c,n),it(l)>p*p)return 0;if(h)return 1;const A=i.createContactEquation(t,o,e,a),g=A.normalA,v=A.contactPointA,E=A.contactPointB;return G(g,l),X(g,g),_(v,g,p),S(v,v,n),B(v,v,t.position),B(E,c,o.position),i.contactEquations.push(A),i.enableFriction&&i.frictionEquations.push(i.createFrictionFromContact(A)),1}})());w(this,"planeCapsule",(()=>{var i=this;return function(t,e,n,s,o,a,c,u,h){h===void 0&&(h=!1);const l=ps,p=ms,A=fs,g=a.length/2;R(l,-g,0),R(p,g,0),H(l,l,c,u),H(p,p,c,u),A.radius=a.radius;let v=!0;i.enableFrictionReduction&&(v=i.enableFriction,i.enableFriction=!1);const E=i.circlePlane(o,A,l,0,t,e,n,s,h),y=i.circlePlane(o,A,p,0,t,e,n,s,h);if(i.enableFrictionReduction&&(i.enableFriction=v),h)return E+y;{const P=E+y;return i.enableFrictionReduction&&P&&i.frictionEquations.push(i.createFrictionFromAverage(P)),P}}})());w(this,"circlePlane",(()=>{var i=this;return function(t,e,n,s,o,a,c,u,h){h===void 0&&(h=!1);const l=e.radius,p=rt,A=ft,g=bt;B(p,n,c),K(A,zt,u);const v=O(A,p);if(v>l)return 0;if(h)return 1;const E=i.createContactEquation(o,t,a,e);G(E.normalA,A);const y=E.contactPointB;_(y,E.normalA,-l),S(y,y,n),B(y,y,t.position);const P=E.contactPointA;return _(g,E.normalA,v),B(P,p,g),S(P,P,c),B(P,P,o.position),i.contactEquations.push(E),i.enableFriction&&i.frictionEquations.push(i.createFrictionFromContact(E)),1}})());w(this,"convexConvex",(()=>{var i=this;return function(t,e,n,s,o,a,c,u,h){h===void 0&&(h=!1);const l=0,p=Kn,A=Gn,g=Vn,v=te(A,e,n,s,a,c,u),E=A[0];if(E>l)return 0;const y=te(g,a,c,u,e,n,s),P=g[0];if(P>l)return 0;let b,m,f,C,M,F,L,V,q;P>E?(b=a,m=e,L=o,V=t,f=c,M=u,C=n,F=s,q=y):(b=e,m=a,L=t,V=o,f=n,M=s,C=c,F=u,q=v);const U=Qn;Cs(U,b,f,M,q,m,C,F);const Y=b.vertices.length,Q=b.vertices,$=q,nt=q+1<Y?q+1:0,N=Hn,k=Yn;G(N,Q[$]),G(k,Q[nt]);const T=kn;B(T,k,N),X(T,T),Pi(Dn,T,1);const di=On;S(di,N,k),_(di,di,.5);const vt=Un;K(vt,T,M);const Ct=Wn;Pi(Ct,vt,1),H(N,N,f,M),H(k,k,f,M);const be=O(Ct,N),Ee=-O(vt,N)+l,Ce=O(vt,k)+l,Gi=zn,Vt=$n;let kt=0;const Vi=Xn;if(_(Vi,vt,-1),kt=ie(Gi,U,Vi,Ee),kt<2||(kt=ie(Vt,Gi,vt,Ce),kt<2))return 0;let Dt=0;for(let yt=0;yt<Zn;++yt){const ki=O(Ct,Vt[yt])-be;if(ki<=l){if(h)return 1;++Dt;const ot=i.createContactEquation(L,V,b,m);G(ot.normalA,Ct),G(ot.contactPointB,Vt[yt]),B(ot.contactPointB,ot.contactPointB,V.position),_(p,Ct,-ki),S(ot.contactPointA,Vt[yt],p),B(ot.contactPointA,ot.contactPointA,L.position),i.contactEquations.push(ot),i.enableFriction&&!i.enableFrictionReduction&&i.frictionEquations.push(i.createFrictionFromContact(ot))}}return Dt&&i.enableFrictionReduction&&i.enableFriction&&i.frictionEquations.push(i.createFrictionFromAverage(Dt)),Dt}})());w(this,"circleHeightfield",(()=>{var i=this;return function(t,e,n,s,o,a,c,u,h,l){h===void 0&&(h=!1),l===void 0&&(l=e.radius);const p=a.heights,A=a.elementWidth,g=jn,v=Jn,E=es,y=ss,P=ns,b=ts,m=is;let f=Math.floor((n[0]-l-c[0])/A),C=Math.ceil((n[0]+l-c[0])/A);f<0&&(f=0),C>=p.length&&(C=p.length-1);let M=p[f],F=p[C];for(let V=f;V<C;V++)p[V]<F&&(F=p[V]),p[V]>M&&(M=p[V]);if(n[1]-l>M)return 0;let L=!1;for(let V=f;V<C;V++){R(b,V*A,p[V]),R(m,(V+1)*A,p[V+1]),S(b,b,c),S(m,m,c),B(P,m,b),K(P,P,Math.PI/2),X(P,P),_(v,P,-l),S(v,v,n),B(g,v,b);const q=O(g,P);if(v[0]>=b[0]&&v[0]<m[0]&&q<=0){if(h)return 1;L=!0,_(g,P,-q),S(E,v,g),G(y,P);const U=i.createContactEquation(o,t,a,e);G(U.normalA,y),_(U.contactPointB,U.normalA,-l),S(U.contactPointB,U.contactPointB,n),B(U.contactPointB,U.contactPointB,t.position),G(U.contactPointA,E),B(U.contactPointA,U.contactPointA,o.position),i.contactEquations.push(U),i.enableFriction&&i.frictionEquations.push(i.createFrictionFromContact(U))}}if(L=!1,l>0){for(let V=f;V<=C;V++)if(R(b,V*A,p[V]),S(b,b,c),B(g,n,b),it(g)<Math.pow(l,2)){if(h)return 1;L=!0;const q=i.createContactEquation(o,t,a,e);G(q.normalA,g),X(q.normalA,q.normalA),_(q.contactPointB,q.normalA,-l),S(q.contactPointB,q.contactPointB,n),B(q.contactPointB,q.contactPointB,t.position),B(q.contactPointA,b,c),S(q.contactPointA,q.contactPointA,c),B(q.contactPointA,q.contactPointA,o.position),i.contactEquations.push(q),i.enableFriction&&i.frictionEquations.push(i.createFrictionFromContact(q))}}return L?1:0}})());w(this,"convexHeightfield",(()=>{var i=this;return function(t,e,n,s,o,a,c,u,h){h===void 0&&(h=!1);const l=a.heights,p=a.elementWidth,A=ys,g=Bs,v=ws,E=Ps;let y=Math.floor((t.aabb.lowerBound[0]-c[0])/p),P=Math.ceil((t.aabb.upperBound[0]-c[0])/p);y<0&&(y=0),P>=l.length&&(P=l.length-1);let b=l[y],m=l[P];for(let C=y;C<P;C++)l[C]<m&&(m=l[C]),l[C]>b&&(b=l[C]);if(t.aabb.lowerBound[1]>b)return 0;let f=0;for(let C=y;C<P;C++){R(A,C*p,l[C]),R(g,(C+1)*p,l[C+1]),S(A,A,c),S(g,g,c);const M=100;R(v,(g[0]+A[0])*.5,(g[1]+A[1]-M)*.5),B(E.vertices[0],g,v),B(E.vertices[1],A,v),G(E.vertices[2],E.vertices[1]),G(E.vertices[3],E.vertices[0]),E.vertices[2][1]-=M,E.vertices[3][1]-=M,E.updateNormals(),f+=i.convexConvex(t,e,n,s,o,E,v,0,h)}return f}})());w(this,"narrowphases",{[I.CONVEX|I.LINE]:this.convexLine,[I.LINE|I.BOX]:this.lineBox,[I.CONVEX|I.CAPSULE]:this.convexCapsule,[I.BOX|I.CAPSULE]:this.convexCapsule,[I.LINE|I.CAPSULE]:this.lineCapsule,[I.CAPSULE]:this.capsuleCapsule,[I.LINE]:this.lineLine,[I.PLANE|I.LINE]:this.planeLine,[I.PARTICLE|I.CAPSULE]:this.particleCapsule,[I.CIRCLE|I.LINE]:this.circleLine,[I.CIRCLE|I.CAPSULE]:this.circleCapsule,[I.CIRCLE|I.CONVEX]:this.circleConvex,[I.CIRCLE|I.BOX]:this.circleConvex,[I.PARTICLE|I.CONVEX]:this.particleConvex,[I.PARTICLE|I.BOX]:this.particleConvex,[I.CIRCLE]:this.circleCircle,[I.PLANE|I.CONVEX]:this.planeConvex,[I.PLANE|I.BOX]:this.planeConvex,[I.PARTICLE|I.PLANE]:this.particlePlane,[I.CIRCLE|I.PARTICLE]:this.circleParticle,[I.PLANE|I.CAPSULE]:this.planeCapsule,[I.CIRCLE|I.PLANE]:this.circlePlane,[I.CONVEX]:this.convexConvex,[I.CONVEX|I.BOX]:this.convexConvex,[I.BOX]:this.convexConvex,[I.CIRCLE|I.HEIGHTFIELD]:this.circleHeightfield,[I.BOX|I.HEIGHTFIELD]:this.convexHeightfield,[I.CONVEX|I.HEIGHTFIELD]:this.convexHeightfield});this.contactEquations=[],this.frictionEquations=[],this.enableFriction=!0,this.enabledEquations=!0,this.slipForce=10,this.contactEquationPool=new Ln({size:32}),this.frictionEquationPool=new Nn({size:64}),this.enableFrictionReduction=!0,this.collidingBodiesLastStep=new ei,this.currentContactMaterial=null}bodiesOverlap(i,t,e){const n=Tn,s=Rn;for(let o=0,a=i.shapes.length;o!==a;o++){const c=i.shapes[o];for(let u=0,h=t.shapes.length;u!==h;u++){const l=t.shapes[u];if(e&&!(c.collisionGroup&l.collisionMask&&l.collisionGroup&c.collisionMask))return!1;if(i.toWorldFrame(n,c.position),t.toWorldFrame(s,l.position),c.type<=l.type){if(this.narrowphases[c.type|l.type](i,c,n,c.angle+i.angle,t,l,s,l.angle+t.angle,!0))return!0}else if(this.narrowphases[c.type|l.type](t,l,s,l.angle+t.angle,i,c,n,c.angle+i.angle,!0))return!0}}return!1}collidedLastStep(i,t){const e=i.id|0,n=t.id|0;return!!this.collidingBodiesLastStep.get(e,n)}reset(){this.collidingBodiesLastStep.reset();const i=this.contactEquations;let t=i.length;for(;t--;){const s=i[t],o=s.bodyA.id,a=s.bodyB.id;this.collidingBodiesLastStep.set(o,a,!0)}const e=this.contactEquations,n=this.frictionEquations;for(let s=0;s<e.length;s++)this.contactEquationPool.release(e[s]);for(let s=0;s<n.length;s++)this.frictionEquationPool.release(n[s]);this.contactEquations.length=this.frictionEquations.length=0}createContactEquation(i,t,e,n){const s=this.contactEquationPool.get(),o=this.currentContactMaterial;return s.bodyA=i,s.bodyB=t,s.shapeA=e,s.shapeB=n,s.enabled=this.enabledEquations,s.firstImpact=!this.collidedLastStep(i,t),s.restitution=o.restitution,s.stiffness=o.stiffness,s.relaxation=o.relaxation,s.offset=o.contactSkinSize,s.needsUpdate=!0,s}createFrictionEquation(i,t,e,n){const s=this.frictionEquationPool.get(),o=this.currentContactMaterial;return s.bodyA=i,s.bodyB=t,s.shapeA=e,s.shapeB=n,s.setSlipForce(this.slipForce),s.enabled=this.enabledEquations,s.frictionCoefficient=o.friction,s.relativeVelocity=o.surfaceVelocity,s.stiffness=o.frictionStiffness,s.relaxation=o.frictionRelaxation,s.needsUpdate=!0,s.contactEquations.length=0,s}createFrictionFromContact(i){const t=this.createFrictionEquation(i.bodyA,i.bodyB,i.shapeA,i.shapeB);return G(t.contactPointA,i.contactPointA),G(t.contactPointB,i.contactPointB),pt(t.t,i.normalA),t.contactEquations.push(i),t}createFrictionFromAverage(i){let t=this.contactEquations[this.contactEquations.length-1];const e=this.createFrictionEquation(t.bodyA,t.bodyB,t.shapeA,t.shapeB),n=t.bodyA;R(e.contactPointA,0,0),R(e.contactPointB,0,0),R(e.t,0,0);for(let o=0;o!==i;o++)t=this.contactEquations[this.contactEquations.length-1-o],t.bodyA===n?(S(e.t,e.t,t.normalA),S(e.contactPointA,e.contactPointA,t.contactPointA),S(e.contactPointB,e.contactPointB,t.contactPointB)):(B(e.t,e.t,t.normalA),S(e.contactPointA,e.contactPointA,t.contactPointB),S(e.contactPointB,e.contactPointB,t.contactPointA)),e.contactEquations.push(t);const s=1/i;return _(e.contactPointA,e.contactPointA,s),_(e.contactPointB,e.contactPointB,s),X(e.t,e.t),pt(e.t,e.t),e}}const zt=Z(0,1),rt=d(),ft=d(),bt=d(),Pt=d(),Mt=d(),xt=d(),$t=d(),vi=d(),zi=d(),$i=d(),Qi=d(),qn=d(),Ai=d(),bi=d(),Zi=d(),Ji=[],Tn=d(),Rn=d(),Gn=d(),Vn=d(),kn=d(),Dn=d(),On=d(),Un=d(),Wn=d(),Xn=d(),Hn=d(),Yn=d(),Kn=d(),zn=[d(),d()],$n=[d(),d()],Qn=[d(),d()],Zn=2,Jn=d(),jn=d(),ts=d(),is=d(),es=d(),ns=d(),ss=d();function Ei(r,i){const t=i.radius,e=i.length*.5,n=r.vertices;R(n[0],-e,-t),R(n[1],e,-t),R(n[2],e,t),R(n[3],-e,t)}const os=new Ni({width:1,height:1}),rs=d(),as=d(),cs=d(),ls=new Ni({width:1,height:1}),hs=d(),ge=d(),ve=d();function ds(r,i,t,e){const n=hs,s=ge,o=ve,a=i.vertices;let c=null;dt(n,r,t,e);for(let u=0,h=a.length;u!==h+1;u++){const l=a[u%h],p=a[(u+1)%h];B(s,l,n),B(o,p,n);const A=st(s,o);if(c===null&&(c=A),A*c<0)return!1;c=A}return!0}function ji(r,i,t,e){r[0]=i[0]+t[0]-e[0],r[1]=i[1]+t[1]-e[1]}function us(r,i){const t=ge,e=ve,n=i.vertices,s=n.length;let o=null;for(let a=0;a<s+1;a++){const c=n[a%s],u=n[(a+1)%s];B(t,c,r),B(e,u,r);const h=st(t,e);if(o===null&&(o=h),h*o<0)return!1;o=h}return!0}const fs=new _i({radius:1}),ps=d(),ms=d(),gs=d(),vs=d(),As=d(),bs=d();function te(r,i,t,e,n,s,o){const a=i.vertices.length,c=n.vertices.length,u=i.normals,h=i.vertices,l=n.vertices,p=gs,A=vs,g=As,v=bs,E=e-o;let y=0,P=-Number.MAX_VALUE;for(let b=0;b<a;++b){K(p,u[b],E),H(v,h[b],t,e),dt(A,v,s,o);let m=Number.MAX_VALUE;for(let f=0;f<c;++f){B(g,l[f],A);const C=O(p,g);C<m&&(m=C)}m>P&&(P=m,y=b)}return r[0]=P,y}const Es=d();function Cs(r,i,t,e,n,s,o,a){const c=i.normals,u=s.vertices.length,h=s.vertices,l=s.normals,p=Es;K(p,c[n],e-a);let A=0,g=Number.MAX_VALUE;for(let y=0;y<u;++y){const P=O(p,l[y]);P<g&&(g=P,A=y)}const v=A,E=v+1<u?v+1:0;H(r[0],h[v],o,a),H(r[1],h[E],o,a)}function ie(r,i,t,e){let n=0;const s=O(t,i[0])-e,o=O(t,i[1])-e;if(s<=0&&G(r[n++],i[0]),o<=0&&G(r[n++],i[1]),s*o<0){const a=s/(s-o),c=r[n];B(c,i[1],i[0]),_(c,c,a),S(c,c,i[0]),++n}return n}const ys=d(),Bs=d(),ws=d(),Ps=new mt({vertices:[d(),d(),d(),d()]});class Ms extends _t{constructor(){super(_t.SAP);w(this,"axisList",[]);w(this,"axisIndex",0);this.addBodyHandler=t=>{this.axisList.push(t.body)},this.removeBodyHandler=t=>{const e=this.axisList.indexOf(t.body);e!==-1&&this.axisList.splice(e,1)}}setWorld(t){this.axisList.length=0,ti(this.axisList,t.bodies),t.off("addBody",this.addBodyHandler).off("removeBody",this.removeBodyHandler),t.on("addBody",this.addBodyHandler).on("removeBody",this.removeBodyHandler),this.world=t}sortList(){const t=this.axisList,e=this.axisIndex;xs(t,e)}getCollisionPairs(t){const e=this.axisList,n=this.result,s=this.axisIndex;n.length=0;let o=e.length;for(;o--;){const a=e[o];a.aabbNeedsUpdate&&a.updateAABB()}this.sortList();for(let a=0,c=e.length|0;a!==c;a++){const u=e[a];for(let h=a+1;h<c;h++){const l=e[h];if(!(l.aabb.lowerBound[s]<=u.aabb.upperBound[s]))break;_t.canCollide(u,l)&&this.boundingVolumeCheck(u,l)&&n.push(u,l)}}return n}aabbQuery(t,e,n){n===void 0&&(n=[]),this.sortList();const s=this.axisList;for(let o=0;o<s.length;o++){const a=s[o];a.aabbNeedsUpdate&&a.updateAABB(),a.aabb.overlaps(e)&&n.push(a)}return n}}function xs(r,i){i=i|0;for(let t=1,e=r.length;t<e;t++){const n=r[t];let s;for(s=t-1;s>=0&&!(r[s].aabb.lowerBound[i]<=n.aabb.lowerBound[i]);s--)r[s+1]=r[s];r[s+1]=n}return r}d();d();d();d();d();d();Z(1,0);Z(0,1);d();d();Z(1,0);Z(0,1);d();d();d();d();d();d();d();d();Z(1,0);Z(0,1);d();const oi=class oi{constructor(){this.id=oi.idCounter++}};w(oi,"idCounter",0);let gt=oi;const ri=class ri{constructor(i,t,e){if(e===void 0&&(e={}),!(i instanceof gt)||!(t instanceof gt))throw new Error("First two arguments must be Material instances.");this.id=ri.idCounter++,this.materialA=i,this.materialB=t,this.friction=e.friction??.3,this.restitution=e.restitution??0,this.stiffness=e.stiffness??ht.DEFAULT_STIFFNESS,this.relaxation=e.relaxation??ht.DEFAULT_RELAXATION,this.frictionStiffness=e.frictionStiffness??ht.DEFAULT_STIFFNESS,this.frictionRelaxation=e.frictionRelaxation??ht.DEFAULT_RELAXATION,this.surfaceVelocity=e.surfaceVelocity??0,this.contactSkinSize=.005}};w(ri,"idCounter",0);let Rt=ri;d();d();d();d();d();d();d();d();d();d();d();d();d();d();d();d();d();Z(0,1);d(),d(),d(),d();d();d();d();d();d();d(),d();d();d();d();Z(0,1);let Is=class extends I{constructor(i){i===void 0&&(i={}),super({...i,type:I.PLANE}),this.updateBoundingRadius(),this.updateArea()}computeMomentOfInertia(){return 0}updateBoundingRadius(){this.boundingRadius=Number.MAX_VALUE}updateArea(){this.area=Number.MAX_VALUE}computeAABB(i,t,e){const n=e%(2*Math.PI),s=R,o=1e7,a=i.lowerBound,c=i.upperBound;s(a,-o,-o),s(c,o,o),n===0?c[1]=t[1]:n===Math.PI/2?a[0]=t[0]:n===Math.PI?a[1]=t[1]:n===3*Math.PI/2&&(c[0]=t[0])}raycast(i,t,e,n){const s=t.from,o=t.to,a=t.direction,c=Ss,u=Fs,h=Ls;R(u,0,1),K(u,u,n),B(h,s,e);const l=O(h,u);B(h,o,e);const p=O(h,u);if(l*p>0||ci(s,o)<l*l)return;const A=O(u,a);B(c,s,e);const g=-O(u,c)/A/t.length;t.reportIntersection(i,g,u,-1)}pointTest(i){return i[1]<=0}};const Ss=d(),Fs=d(),Ls=d();class Ci{constructor(i,t){i===void 0&&(i={}),this.type=t,this.equations=[],this.equationSortFunction=i.equationSortFunction}sortEquations(){this.equationSortFunction&&this.equations.sort(this.equationSortFunction)}addEquation(i){i.enabled&&this.equations.push(i)}addEquations(i){for(let t=0,e=i.length;t!==e;t++){const n=i[t];n.enabled&&this.equations.push(n)}}removeEquation(i){const t=this.equations.indexOf(i);t!==-1&&this.equations.splice(t,1)}removeAllEquations(){this.equations.length=0}}class Ns extends Ci{constructor(t){t===void 0&&(t={});super(t,Ci.GS);w(this,"type",Ci.GS);this.iterations=t.iterations??10,this.tolerance=t.tolerance??1e-7,this.frictionIterations=t.frictionIterations??0,this.usedIterations=0}solve(t,e){this.sortEquations();let n=0;const s=this.iterations,o=this.frictionIterations,a=this.equations,c=a.length,u=Math.pow(this.tolerance*c,2),h=e.bodies,l=h.length;if(this.usedIterations=0,c)for(let E=0;E!==l;E++)h[E].updateSolveMassProperties();for(let E=0;E!==c;E++){const y=a[E];y.lambda=0,(y.timeStep!==t||y.needsUpdate)&&(y.timeStep=t,y.update()),y.B=y.computeB(y.a,y.b,t),y.invC=y.computeInvC(y.epsilon),y.maxForceDt=y.maxForce*t,y.minForceDt=y.minForce*t}let p,A,g,v;if(c!==0){for(g=0;g!==l;g++)h[g].resetConstraintVelocity();if(o){for(n=0;n!==o;n++){for(A=0,v=0;v!==c;v++){p=a[v];const E=ne(p);A+=Math.abs(E)}if(this.usedIterations++,A*A<=u)break}for(ee(a,1/t),v=0;v!==c;v++){const E=a[v];if(E instanceof me){let y=0;for(let P=0;P!==E.contactEquations.length;P++)y+=E.contactEquations[P].multiplier;y*=E.frictionCoefficient/E.contactEquations.length,E.maxForce=y,E.minForce=-y,E.maxForceDt=y*t,E.minForceDt=-y*t}}}for(n=0;n!==s;n++){for(A=0,v=0;v!==c;v++){p=a[v];const E=ne(p);A+=Math.abs(E)}if(this.usedIterations++,A*A<u)break}for(g=0;g!==l;g++)h[g].addConstraintVelocity();ee(a,1/t)}}}function ee(r,i){let t=r.length;for(;t--;){const e=r[t];e.multiplier=e.lambda*i}}function ne(r){const i=r.B,t=r.epsilon,e=r.invC,n=r.lambda,s=r.computeGWlambda(),o=r.maxForceDt,a=r.minForceDt;let c=e*(i-s-t*n);const u=n+c;return u<a?c=a-n:u>o&&(c=o-n),r.lambda+=c,r.addToWlambda(c),c}class _s{constructor(i,t,e,n){this.bodyA=i,this.shapeA=t,this.bodyB=e,this.shapeB=n}set(i,t,e,n){this.bodyA=i,this.shapeA=t,this.bodyB=e,this.shapeB=n}}class qs extends qi{create(){return new _s(Bi,yi,Bi,yi)}destroy(i){return i.bodyA=i.bodyB=Bi,i.shapeA=i.shapeB=yi,this}}const yi=new _i({radius:1}),Bi=new D;class Ts{constructor(){this.overlappingShapesLastState=new ei,this.overlappingShapesCurrentState=new ei,this.recordPool=new qs({size:16}),this.tmpDict=new ei,this.tmpArray1=[]}tick(){const i=this.overlappingShapesLastState,t=this.overlappingShapesCurrentState;let e=i.keys.length;for(;e--;){const n=i.keys[e],s=i.getByKey(n);s&&this.recordPool.release(s)}i.copy(t),t.reset()}bodiesAreOverlapping(i,t){const e=this.overlappingShapesCurrentState;let n=e.keys.length;for(;n--;){const s=e.keys[n],o=e.data[s];if(o.bodyA===i&&o.bodyB===t||o.bodyA===t&&o.bodyB===i)return!0}return!1}setOverlapping(i,t,e,n){const s=this.overlappingShapesCurrentState;if(!s.get(t.id,n.id)){const o=this.recordPool.get();o.set(i,t,e,n),s.set(t.id,n.id,o)}}getNewOverlaps(i){return this.getDiff(this.overlappingShapesLastState,this.overlappingShapesCurrentState,i)}getEndOverlaps(i){return this.getDiff(this.overlappingShapesCurrentState,this.overlappingShapesLastState,i)}getDiff(i,t,e){e===void 0&&(e=[]);const n=i,s=t;e.length=0;let o=s.keys.length;for(;o--;){const a=s.keys[o],c=s.data[a];if(!c)throw new Error("Key "+a+" had no data!");n.data[a]||e.push(c)}return e}isNewOverlap(i,t){const e=i.id|0,n=t.id|0,s=this.overlappingShapesLastState,o=this.overlappingShapesCurrentState;return!s.get(e,n)&&!!o.get(e,n)}getNewBodyOverlaps(i){this.tmpArray1.length=0;const t=this.getNewOverlaps(this.tmpArray1);return this.getBodyDiff(t,i)}getEndBodyOverlaps(i){this.tmpArray1.length=0;const t=this.getEndOverlaps(this.tmpArray1);return this.getBodyDiff(t,i)}getBodyDiff(i,t){t===void 0&&(t=[]);const e=this.tmpDict;let n=i.length;for(;n--;){const s=i[n];e.set(s.bodyA.id|0,s.bodyB.id|0,s)}for(n=e.keys.length;n--;){const s=e.getByKey(e.keys[n]);s&&t.push(s.bodyA,s.bodyB)}return e.reset(),t}}class Rs{constructor(i){w(this,"id",[]);w(this,"sz",[]);this.size=i,this.count=i,this.resize(i)}resize(i){this.count=this.size=i;const t=this.sz,e=this.id;for(let n=0;n<i;n++)e[n]=n,t[n]=1}find(i){const t=this.id;for(;i!==t[i];)t[i]=t[t[i]],i=t[i];return i}union(i,t){const e=this.find(i),n=this.find(t);if(e===n)return;const s=this.sz,o=this.id;s[e]<s[n]?(o[e]=n,s[n]+=s[e]):(o[n]=e,s[e]+=s[n]),this.count--}}const lt=class lt extends pe{constructor(t){t===void 0&&(t={});super();w(this,"springs",[]);w(this,"bodies",[]);w(this,"hasActiveBodies",!1);w(this,"narrowphase",new _n);w(this,"useWorldGravityAsFrictionGravity",!0);w(this,"useFrictionGravityOnZeroGravity",!0);w(this,"constraints",[]);w(this,"lastTimeStep",1/60);w(this,"applySpringForces",!0);w(this,"applyDamping",!0);w(this,"applyGravity",!0);w(this,"solveConstraints",!0);w(this,"contactMaterials",[]);w(this,"time",0);w(this,"accumulator",0);w(this,"stepping",!1);w(this,"emitImpactEvent",!0);w(this,"sleepMode",lt.NO_SLEEPING);w(this,"overlapKeeper",new Ts);w(this,"disabledBodyCollisionPairs",[]);w(this,"unionFind",new Rs(1));this.solver=t.solver||new Ns,this.gravity=Z(0,-9.78),t.gravity&&G(this.gravity,t.gravity),this.frictionGravity=qt(this.gravity)||10,this.broadphase=t.broadphase||new Ms,this.broadphase.setWorld(this),this.defaultMaterial=new gt,this.defaultContactMaterial=new Rt(this.defaultMaterial,this.defaultMaterial),this.islandSplit=t.islandSplit??!0}addConstraint(t){if(this.stepping)throw new Error("Constraints cannot be added during step.");const e=this.bodies;if(e.indexOf(t.bodyA)===-1)throw new Error("Cannot add Constraint: bodyA is not added to the World.");if(e.indexOf(t.bodyB)===-1)throw new Error("Cannot add Constraint: bodyB is not added to the World.");this.constraints.push(t)}addContactMaterial(t){this.contactMaterials.push(t)}removeContactMaterial(t){Ot(this.contactMaterials,t)}getContactMaterial(t,e){const n=this.contactMaterials;for(let s=0,o=n.length;s!==o;s++){const a=n[s];if(a.materialA===t&&a.materialB===e||a.materialA===e&&a.materialB===t)return a}return!1}removeConstraint(t){if(this.stepping)throw new Error("Constraints cannot be removed during step.");Ot(this.constraints,t)}step(t,e,n){if(n===void 0&&(n=10),e===void 0)this.internalStep(t),this.time+=t;else{this.accumulator+=e;let s=0;for(;this.accumulator>=t&&s<n;)this.internalStep(t),this.time+=t,this.accumulator-=t,s++;const o=this.accumulator%t/t;for(let a=0;a!==this.bodies.length;a++){const c=this.bodies[a];Ft(c.interpolatedPosition,c.previousPosition,c.position,o),c.interpolatedAngle=c.previousAngle+o*(c.angle-c.previousAngle)}}}internalStep(t){this.stepping=!0;const e=this.springs.length,n=this.springs,s=this.bodies,o=this.gravity,a=this.solver,c=this.bodies.length,u=this.broadphase,h=this.narrowphase,l=this.constraints,p=Ds,A=S;if(this.overlapKeeper.tick(),this.lastTimeStep=t,this.useWorldGravityAsFrictionGravity){const m=qt(this.gravity);m===0&&this.useFrictionGravityOnZeroGravity||(this.frictionGravity=m)}if(this.applyGravity)for(let m=0;m!==c;m++){const f=s[m],C=f.force;f.type!==D.DYNAMIC||f.sleepState===D.SLEEPING||(_(p,o,f.mass*f.gravityScale),A(C,C,p))}if(this.applySpringForces)for(let m=0;m!==e;m++)n[m].applyForce();if(this.applyDamping)for(let m=0;m!==c;m++){const f=s[m];f.type===D.DYNAMIC&&f.applyDamping(t)}const g=u.getCollisionPairs(this),v=this.disabledBodyCollisionPairs;for(let m=v.length-2;m>=0;m-=2)for(let f=g.length-2;f>=0;f-=2)(v[m]===g[f]&&v[m+1]===g[f+1]||v[m+1]===g[f]&&v[m]===g[f+1])&&g.splice(f,2);let E=l.length;for(let m=0;m!==E;m++){const f=l[m];if(!f.collideConnected)for(let C=g.length-2;C>=0;C-=2)(f.bodyA===g[C]&&f.bodyB===g[C+1]||f.bodyB===g[C]&&f.bodyA===g[C+1])&&g.splice(C,2)}this.emit({type:"postBroadphase",pairs:g}),h.reset();const y=this.defaultContactMaterial,P=this.frictionGravity;for(let m=0,f=g.length;m!==f;m+=2){const C=g[m],M=g[m+1];for(let F=0,L=C.shapes.length;F!==L;F++){const V=C.shapes[F],q=V.position,U=V.angle;for(let Y=0,Q=M.shapes.length;Y!==Q;Y++){const $=M.shapes[Y],nt=$.position,N=$.angle;let k=!1;V.material&&$.material&&(k=this.getContactMaterial(V.material,$.material)),ks(this,h,C,V,q,U,M,$,nt,N,k||y,P)}}}for(let m=0;m!==c;m++){const f=s[m];f._wakeUpAfterNarrowphase&&(f.wakeUp(),f._wakeUpAfterNarrowphase=!1)}if(this.has("endContact")){this.overlapKeeper.getEndOverlaps(Jt);let m=Jt.length;for(;m--;){const f=Jt[m],C={type:"endContact",shapeA:f.shapeA,shapeB:f.shapeB,bodyA:f.bodyA,bodyB:f.bodyB};this.emit(C)}Jt.length=0}this.emit({type:"preSolve",contactEquations:h.contactEquations,frictionEquations:h.frictionEquations}),E=l.length;for(let m=0;m!==E;m++)l[m].update();if(h.contactEquations.length||h.frictionEquations.length||E){let m=[];ti(m,h.contactEquations),ti(m,h.frictionEquations);for(let f=0;f!==E;f++)ti(m,l[f].equations);if(this.islandSplit){const f=this.unionFind;f.resize(this.bodies.length+1);for(let M=0;M<m.length;M++)m[M].index=M;for(let M=0;M<m.length;M++){const F=m[M].bodyA,L=m[M].bodyB;F.type===D.DYNAMIC&&L.type===D.DYNAMIC&&f.union(F.index,L.index)}for(let M=0;M<s.length;M++){const F=s[M];F.islandId=F.type===D.DYNAMIC?f.find(F.index):-1}m=m.sort(Vs);let C=0;for(;C<m.length;){const M=m[C++];a.addEquation(M);const F=M.bodyA.islandId>0?M.bodyA.islandId:M.bodyB.islandId;let L=-1;m[C]&&(L=m[C].bodyA.islandId>0?m[C].bodyA.islandId:m[C].bodyB.islandId),(L!==F||C===m.length)&&(this.solveConstraints&&a.solve(t,this),a.removeAllEquations())}}else a.addEquations(m),this.solveConstraints&&a.solve(t,this),a.removeAllEquations()}for(let m=0;m!==c;m++){const f=s[m];(f.type===D.DYNAMIC||f.type===D.KINEMATIC)&&f.integrate(t)}for(let m=0;m!==c;m++)s[m].setZeroForce();if(this.emitImpactEvent&&this.has("impact"))for(let m=0;m!==h.contactEquations.length;m++){const f=h.contactEquations[m];f.firstImpact&&this.emit({type:"impact",bodyA:f.bodyA,bodyB:f.bodyB,shapeA:f.shapeA,shapeB:f.shapeB,contactEquation:f})}let b=!0;if(this.sleepMode===lt.BODY_SLEEPING){b=!1;for(let m=0;m!==c;m++){const f=s[m];f.sleepTick(this.time,!1,t),f.sleepState!==D.SLEEPING&&f.type!==D.STATIC&&(b=!0)}}else if(this.sleepMode===lt.ISLAND_SLEEPING&&this.islandSplit){for(let C=0;C!==c;C++)s[C].sleepTick(this.time,!0,t);const m=s.sort(Gs);let f=1;for(let C=0;C<m.length;C=f){const M=m[C].islandId;for(f=C+1;f<m.length&&m[f].islandId===M;f++);if(M===-1)continue;let F=!0;for(let L=C;L<f;L++)if(!m[L].wantsToSleep){F=!1;break}if(F)for(let L=C;L<f;L++)m[L].sleep()}b=!1;for(let C=0;C!==c;C++){const M=s[C];if(M.sleepState!==D.SLEEPING&&M.type!==D.STATIC){b=!0;break}}}this.hasActiveBodies=b,this.stepping=!1,this.emit({type:"postStep"})}addSpring(t){if(this.stepping)throw new Error("Springs cannot be added during step.");this.springs.push(t),this.emit({type:"addSpring",spring:t})}removeSpring(t){if(this.stepping)throw new Error("Springs cannot be removed during step.");Ot(this.springs,t),this.emit({type:"removeSpring",spring:t})}addBody(t){if(this.stepping)throw new Error("Bodies cannot be added during step.");if(t.world)throw new Error("Body is already added to a World.");t.index=this.bodies.length,this.bodies.push(t),t.world=this,this.emit({type:"addBody",body:t})}removeBody(t){if(this.stepping)throw new Error("Bodies cannot be removed during step.");const e=this.constraints;let n=e.length;for(;n--;)if(e[n].bodyA===t||e[n].bodyB===t)throw new Error("Cannot remove Body from World: it still has constraints connected to it.");t.world=null;const s=this.bodies;for(Ot(s,t),t.index=-1,n=s.length;n--;)s[n].index=n;t.resetConstraintVelocity(),this.emit({type:"removeBody",body:t});const o=this.disabledBodyCollisionPairs;let a=0;for(;a<o.length;)o[a]===t||o[a+1]===t?o.splice(a,2):a+=2}getBodyByID(t){const e=this.bodies;for(let n=0;n<e.length;n++){const s=e[n];if(s.id===t)return s}return!1}disableBodyCollision(t,e){this.disabledBodyCollisionPairs.push(t,e)}enableBodyCollision(t,e){const n=this.disabledBodyCollisionPairs;for(let s=0;s<n.length;s+=2)if(n[s]===t&&n[s+1]===e||n[s+1]===t&&n[s]===e){n.splice(s,2);return}}clear(){this.solver.removeAllEquations();const t=this.constraints;let e=t.length;for(;e--;)this.removeConstraint(t[e]);const n=this.bodies;for(e=n.length;e--;)this.removeBody(n[e]);const s=this.springs;for(e=s.length;e--;)this.removeSpring(s[e]);const o=this.contactMaterials;for(e=o.length;e--;)this.removeContactMaterial(o[e])}hitTest(t,e,n){n===void 0&&(n=0);const s=Os,o=Us,a=[];for(let c=0,u=e.length;c!==u;c++){const h=e[c];for(let l=0,p=h.shapes.length;l!==p;l++){const A=h.shapes[l];A.worldPointToLocal(o,t),A.pointTest(o)?a.push(h):(K(s,A.position,h.angle),S(s,s,h.position),A.type===I.PARTICLE&&ci(s,t)<n*n&&a.push(h))}}return a}setGlobalStiffness(t){this.setGlobalEquationParameters({stiffness:t});const e=this.contactMaterials;for(let s=0;s!==e.length;s++){const o=e[s];o.stiffness=o.frictionStiffness=t}const n=this.defaultContactMaterial;n.stiffness=n.frictionStiffness=t}setGlobalRelaxation(t){this.setGlobalEquationParameters({relaxation:t});for(let n=0;n!==this.contactMaterials.length;n++){const s=this.contactMaterials[n];s.relaxation=s.frictionRelaxation=t}const e=this.defaultContactMaterial;e.relaxation=e.frictionRelaxation=t}raycast(t,e){return e.getAABB(se),this.broadphase.aabbQuery(this,se,wi),e.intersectBodies(t,wi),wi.length=0,t.hasHit()}setGlobalEquationParameters(t){const e=this.constraints;for(let n=0;n!==e.length;n++){const o=e[n].equations;for(let a=0;a!==o.length;a++){const c=o[a];c.relaxation=t.relaxation??c.relaxation,c.stiffness=t.stiffness??c.stiffness,c.needsUpdate=!0}}}};w(lt,"NO_SLEEPING",1),w(lt,"BODY_SLEEPING",2),w(lt,"ISLAND_SLEEPING",4);let Si=lt;function Gs(r,i){return r.islandId-i.islandId}function Vs(r,i){const t=r.bodyA.islandId>0?r.bodyA.islandId:r.bodyB.islandId,e=i.bodyA.islandId>0?i.bodyA.islandId:i.bodyB.islandId;return t!==e?t-e:r.index-i.index}function ks(r,i,t,e,n,s,o,a,c,u,h,l){if(!(e.collisionGroup&a.collisionMask&&a.collisionGroup&e.collisionMask)||(H(Qt,n,t.position,t.angle),H(Zt,c,o.position,o.angle),Fi(Qt,Zt)>e.boundingRadius+a.boundingRadius))return;const p=s+t.angle,A=u+o.angle;i.enableFriction=h.friction>0;let g;t.type===D.STATIC||t.type===D.KINEMATIC?g=o.mass:o.type===D.STATIC||o.type===D.KINEMATIC?g=t.mass:g=t.mass*o.mass/(t.mass+o.mass),i.slipForce=h.friction*l*g,i.currentContactMaterial=h,i.enabledEquations=t.collisionResponse&&o.collisionResponse&&e.collisionResponse&&a.collisionResponse;const v=i.narrowphases[e.type|a.type];let E=0;if(v){const y=e.sensor||a.sensor,P=i.frictionEquations.length;e.type<a.type?E=v.call(i,t,e,Qt,p,o,a,Zt,A,y):E=v.call(i,o,a,Zt,A,t,e,Qt,p,y);const b=i.frictionEquations.length-P;if(E){if(t.allowSleep&&t.type===D.DYNAMIC&&t.sleepState===D.SLEEPING&&o.sleepState===D.AWAKE&&o.type!==D.STATIC){const m=it(o.velocity)+Math.pow(o.angularVelocity,2),f=Math.pow(o.sleepSpeedLimit,2);m>=f*2&&(t._wakeUpAfterNarrowphase=!0)}if(o.allowSleep&&o.type===D.DYNAMIC&&o.sleepState===D.SLEEPING&&t.sleepState===D.AWAKE&&t.type!==D.STATIC){const m=it(t.velocity)+Math.pow(t.angularVelocity,2),f=Math.pow(t.sleepSpeedLimit,2);m>=f*2&&(o._wakeUpAfterNarrowphase=!0)}if(r.overlapKeeper.setOverlapping(t,e,o,a),r.has("beginContact")&&r.overlapKeeper.isNewOverlap(e,a)){const m=[];if(!y)for(let f=i.contactEquations.length-E;f<i.contactEquations.length;f++)m.push(i.contactEquations[f]);r.emit({type:"beginContact",shapeA:e,shapeB:a,bodyA:t,bodyB:o,contactEquations:m})}if(!y&&b>1)for(let m=i.frictionEquations.length-b;m<i.frictionEquations.length;m++){const f=i.frictionEquations[m];f.setSlipForce(f.getSlipForce()/b)}}}}const se=new Li,wi=[],Ds=d(),Qt=d(),Zt=d(),Jt=[],Os=d(),Us=d(),oo={title:"React / External Physics Library"},Ti=new gt,Ri=new gt,Ws=new Rt(Ti,Ri,{friction:.75}),Xs=new Rt(Ti,Ri,{friction:.75});class Hs extends Pe{constructor(){super(...arguments);w(this,"bodiesQuery",this.query(t=>t.has("rigidBody")));w(this,"physicsWorld",new Si({gravity:[0,-9.81]}))}onInit(){this.physicsWorld.addContactMaterial(Ws),this.physicsWorld.addContactMaterial(Xs),this.bodiesQuery.onEntityAdded.add(t=>{this.physicsWorld.addBody(t.rigidBody)}),this.bodiesQuery.onEntityRemoved.add(t=>{this.physicsWorld.removeBody(t.rigidBody)})}onUpdate(t){const e=.016666666666666666,n=30;this.physicsWorld.step(e,t,n);for(const s of this.bodiesQuery){const{object3D:o}=s;if(o===void 0)continue;const{rigidBody:a}=s;o.position.set(a.position[0],a.position[1],0),o.rotation.set(0,0,a.angle)}}}const li=new we({components:["object3D","rigidBody"]});li.registerSystem(Hs);li.init();const{Entity:Ae,Component:Ys,Entities:Ks}=xe(li),zs=()=>{const r=ce.useMemo(()=>{const i=new D({position:[0,-2]});return i.addShape(new Is({material:Ri})),i},[]);return z(Ae,{rigidBody:r})},It=({position:r,width:i,height:t})=>{const e=ce.useMemo(()=>{const n=new D({mass:1,position:[...r]});return n.addShape(new Ni({width:i,height:t,material:Ti})),n},[]);return z(Ae,{rigidBody:e})},$s=()=>(Se((r,i)=>{li.step(i)}),Bt(Me,{children:[z(zs,{}),Bt(Fe,{seconds:3,children:[z(It,{width:.5,height:.5,position:[0,0]}),z(It,{width:2,height:.5,position:[-.2,1]}),z(It,{width:.5,height:.5,position:[.2,2]}),z(It,{width:1,height:.5,position:[-.2,3]}),z(It,{width:.5,height:.5,position:[.2,4]})]}),z(Ks,{where:r=>r.has("rigidBody"),children:r=>{const{rigidBody:i}=r,t=[],e=[];for(const n of i.shapes)n.type===I.BOX?t.push(n):n.type===I.PLANE&&e.push(n);return z(Ys,{name:"object3D",children:Bt("group",{children:[t.map((n,s)=>Bt("mesh",{children:[z("meshStandardMaterial",{color:"orange"}),z("boxGeometry",{args:[n.width,n.height,.5]})]},s)),e.map((n,s)=>Bt("mesh",{rotation:[-Math.PI/2,0,n.angle],children:[z("meshStandardMaterial",{color:"#333"}),z("planeGeometry",{args:[100,100]})]},s))]})})}}),z("ambientLight",{intensity:1.5}),z("directionalLight",{intensity:3,position:[10,10,-2]})]})),jt=()=>z(Ie,{camera:{position:[0,0,-10],fov:50},children:z($s,{})});var oe,re,ae;jt.parameters={...jt.parameters,docs:{...(oe=jt.parameters)==null?void 0:oe.docs,source:{originalSource:`() => {
  return <Canvas camera={{
    position: [0, 0, -10],
    fov: 50
  }}>
      <App />
    </Canvas>;
}`,...(ae=(re=jt.parameters)==null?void 0:re.docs)==null?void 0:ae.source}}};const ro=["Example"];export{jt as Example,ro as __namedExportsOrder,oo as default};
